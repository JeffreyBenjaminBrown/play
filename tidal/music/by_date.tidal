--
let scales = [[1,8/7,9/7,10/7,10/6,11/6,12/6,12/5]]
let lkScale = ((M.fromList $ zip [1..] scales) !)::Int->[Double]
let ins = sd "sy" |*| qf "185" |*| end "0.5" -- instrument
let qf' scPat degPat = qf $. runDegPat lkji lkScale scPat degPat |*| ins
let wav p = cat [p, rev p]
dur 6
d1 $ sl 2 $ ssr fa [2,1] $ qf' (slow 4 $ "1") $. st [fast 4 $ run 12, fa 2 $ run 12, jux rev $ run 12] |*| ga "0.7"
d2 $ fa 4 $ ev 2 $. jux (rl $ 1/6) $ sd "bd [sn [hc sn]/2 hc]/3" |*| sl 16 $. ga $. (\x->(x/2)+0.5)<$>tri1 |*| ga "0.6"

-- make tandem :: drum parts & series of scales
let to1to2 x = x / 2**(fromIntegral $ floor $ log x / log 2) -- to the interval [1,2] -- ** was hard!
let scales = fmap (fmap to1to2) [take n [3,5..] | n <- [6..11]] --  ** was hard! b/c map is obscured and <$> I could not nest properly
let lkScale = ((M.fromList $ zip [1..] scales) !)::Int->[Double]
let ins = sd "sy" |*| qf "125" -- instrument
let rootSeq = qf $. slow 4 $. "2 2.05 2.2 2.1" -- "1 1.2 1 0.9"
let qf' scPat degPat = qf $. runDegPat lkji lkScale scPat degPat |*| ins |*| rootSeq
let wav p = cat [p, rev p]
dur 6
d1 $ sl 2 $ ssr fa [2,1] $ qf' (slow 4 $ "1 3 [4 5 6] 2") $. (fast 4 $ run 12) |*| ga "0.7"
d2 $ fa 4 $ ev 2 $. jux (rl $ 1/6) $ sd "bd [sn [hc sn]/2 hc]/3" |*| sl 16 $. ga $. (\x->(x/2)+0.5)<$>tri1 |*| ga "0.6"

-- 2016 10 18 **
let scales = [take n [5,7..] | n <- [1..6]]
let lkScale = ((M.fromList $ zip [1..] scales) !)::Int->[Double]
let ins = sd "sy" |*| qf "20" -- instrument
let rootSeq = qf $. slow 4 $. "1 1.2 1 0.9"
let qf' scPat degPat = qf $. runDegPat lkji lkScale scPat degPat |*| ins |*| rootSeq
let wav p = cat [p, rev p]
d1 $ sl 4 $ ssr fa [2,1,2,4] $ qf' (slow 4 $ "1 3 [4 5 6] 2") $. (fast 4 $ run 8) |*| qfa "2.4" |*| qff "3"
d2 $ fa 4 $ ev 2 $. jux (rl $ 1/6) $ sd "bd [sn [hc sn]/2 hc]/3" |*| sl 16 $. ga $. (\x->(x/2)+0.5)<$>tri1
dur 2

-- ? just do these
dur 1
d1 $ qf "200 250" |*| sl 6 $. qf "1 1.5 0.825]" |*| qf "1.5" |*| sd "sy" -- 8/7: totally unlike 7/4. lower =(always?) denom.
d1 $ qf "200 250" |*| sl 6 $. qf "[1, 0.825]" |*| qf "1.5" |*| sd "sy"

--

dur 1.2
d1 $ slow 4 $ sd "[bd sn] [sn*2 bd] [bd bd*2] ~"
d2 $ sd "hh*4"

--
dur 1.2
d1 $ sd $ st [ev 2 (rl (1/2)) "[bd sn]/2", "hh*5"]

-- 2016 10 08
-- use 
let cp = compress
dur 2
d1 $ st [cp (4/32,(4+8)/32) $ sd "hh*4", cp (0,1/2) $ sd "bd*4"]


spls = take 8 $ repeat ("bd" :: PS)
silences = take 7 $ repeat ("~" :: PS)
f cycDur noteDur notesCt spl = cat $ concat $ [spls, silence] where spls = 1; silence = 2
  -- ct = count
-- also considered using densityGap, withQueryArc

-- to underst compress
dur 2 -- a **
d1 $ compress (0,5/7) $ sd "lt*4"
d2 $ fa 4 $ sd "ho"

dur $ 3/2 -- b **
d1 $ compress (0,6/7) $ sd "bd*4"
d2 $ fa 7 $ sd "hh"

dur 2 -- a
d1 $ ssr compress [(0,5/7),(1/7,6/7)] $ sd "lt*4"
d2 $ fa 4 $ sd "ho"



-- trying to understand withQueryArc (unfinished)
d1 $ withQueryArc (\(a,b)-> (a, (a+b)/2)) $ sd "bd*3 sn*2"
d2 $ sd "~! hh ~!!"
d1 $ withQueryArc id $ sd "bd*3 sn*2"

d1 $ withQueryArc (\(a,b)-> (a, (a+b)/2)) $ sl 2 $ sd "bd*3 sn*4"

-- during stick
dur 1.5
let p1 = sd "hc hh" |*| ga "1 1.2"
d1 $ sl 2 $ st [p1, rr (1/4) p1 |*| ga "0.8"]


READ HEAD spelunking downward is marked ">>>"

dur 2 -- **
d1 $ sd "bd [ho! ~~]/4"
d2 $ rl (1/16) $ sd "hh*4"
d3 $ rl (1/8) $ sd "hc*4" |*| ga "0.8g "
d3 $ si

-- drbwwa == didn't read below when writing above

dur 0.8
d1 $ sl 6 $ sd "bd ~! bd ~! bd ~! bd ~! sn ~!! sn ~!! sn ~!!"
d1 $ si
d2 $ ev 2 (rr $ 1/4) $ sd "~ hc*2"
d2 $ si

--

let ch a b c d = st' $ (/) <$> [a..b] <*> [c..d]
let p1a = cat [ch 2 3 3 4, ch 3 4 5 6] 
let p1b = cat [ch 3 3 7 11, ch 7 9 5 7] 
let p1x = cat [ch 7 11 9 9, ch 7 10 11 11] 
let p2a = cat [p1a, p1b, p1a, p1a]
let p2b = cat [p1a, p1x, p1x, p1a]
let p3 = cat [p2a, p2b]
d1 $ qf $. st' [1,9/7,10/1.5,8/7] |*| qf "400" |*| sd "sya" |*| end "0.9"
d2 $ fa 1 $. qf "1 ~ 1.2 1.15" |*| slow 2 $. qf p3 |*| qf "400" |*| sd "sya" |*| qpf "20" |*| qpa "2" |*| sl 4 $. ga sine1
d3 $ rl (1/4) $ sd "bd ~ ~ [sn*6 sn]/4"
-- next: d1 solo!

d1 $ qf $. st' [1,9/7,3/2,2.2,8/7] |*| qf "400" |*| sd "sya" |*| end "0.9"
d1 $ qf $. st' [2,9/5,3/2,2,8/7] |*| qf "400" |*| sd "sya" |*| end "0.9"
d1 $ qf $. st' [5/2,3/4,3,6/15,7/25,2,1/2] |*| qf "400" |*| sd "sya" |*| end "0.9"
d1 $ si

let p1 = "0 2 4 6 7 ~ 9 10"
d1 $ rl (1/6) $ slow 2 $ sd "hh [sn ~ sn*2]/2"
d2 $ si
d2 $ rl (1/8) $ slow 2 $ sd "hc*2 hc*3"
d3 $ sd "ba"

d1 $ up "p1" |*| sd "sy"


-- **** CHORD PROGRESSIONS
cps 0.2
let major = [0,2,4,5,7,9,11]
let dorian = [0,2,3,5,7,9,10]
d1 $ up $. unwrap $. (fmap (fmap . lk12 . (\v -> case v of 1 -> major; 2 -> dorian)) ("1!! 2" :: PI)) <*> (pure $ fast 4 $ Sound.Tidal.Context.run 7) |*| sd "ps" 
-- <*> is infixl 4, applies degree pattern (on right) to scale pattern (on left). |*| is infixl 1.

-- ** simplifying (unfinished)
let scales = M.fromList [("maj",major),("dor",dorian)]
let whichScale scales string = maybe [] id (M.lookup scales string)
let degreesToPitches scales scalePat degPat = unwrap $. (fmap (fmap . lk12 . whichScale scales) scalePat) <*> (pure $ degPat)
d1 $ up $. degreesToPitches scales ("maj!! dor"::PS) (fast 4 $ Sound.Tidal.Context.run 7) |*| sd "psr"

-- ** THE (3^1,5^1,7^1) SCALE! And a minor!
dur 8
let s357 = [1,35/32,5/4,21/16,3/2,105/64,7/4,15/8]
let reordered = [2,3/2,15/8,5/2,105/64,35/16,7/4,21/16] -- min = 5/4, not 1 or 7/8
let reordered = [1,5/4,15/8,3/2,105/64,21/16,7/8,35/32] -- 7/8 < 1
let reordered = [1,3/2,15/8,5/4,105/64,35/32,7/8,21/16] -- 7/8 < 1
let reordered = [5/6,1,5/4,15/8,3/2,  105/64,21/16,7/8,35/48,35/32] -- 7/8 < 1 + minor (5/6 and 35/48), rhyt 5/4
d1 $ qf $. ca' reordered |*| slow 2 $. qf "80 120" |*| sd "sya" |*| ga "1.1" |*| end $. p 5.4 |*| fast (3/2) $. qaf "2!! 7! 6.5" -- cplx
d1 $ qf $. ca' reordered |*| qf "100" |*| sd "sya" |*| ga "1.1" |*| end $. p 5.4 |*| fast (3/2) $. qaf "2 5" -- **

dur 3 -- ** red cumbia xylophone
let denSca denom = map (flip (/) denom) [denom..denom*2-1]
let sca = denSca 9
d2 $ cyc fast [1,4,2,4] $ slow 4 $ cyc chop [1,1,3,4] $ fast 2 $ sd "bd:1 ~ ~ sn:2 bd ~ sn:2 ~" -- **
d1 $ slow 2 $ st [qf $. fmap (lkji sca) $. ca' $. zipNoTuple [1..18] $. reverse [11..24], rr (0.93/16) $. qf "[2,5,7,5.5/4,8.5/4]*8"] |*| slow 4 $. qf "100 [40,60]" |*| sd "sya" |*| qpa "5" |*| slow 4 $. qpf "2 0.5" -- **

d1 $ slow 2 $ st [qf $. fmap (lkji sca) $. ca' $. zipNoTuple [1..18] $. reverse [11..24], rr (0.93/16) $. qf "[2,5,7,5.5/4,8.5/4]*8"] |*| slow 4 $. qf "[200,210] [40,80]" |*| sd "sya" |*| qpa "5" |*| slow 4 $. qpf "2 0.5" -- **
d3 $ fast 4 $ sd "hh*4 [hh*2 hc*2]/2" |*| ga "1.1"

d1 $ qf $. fmap (lkji sca) "0 [7 [10*4 9*4]/8]*2 [1,2] [2,3] [5,4]"   |*| qf "100" |*| sd "sya"


let a=1:b; b=4:a in take 10 a

dur 6
let reordered = [1,7/6,3/2,11/8,49/24,7/4,77/48,21/8]
d1 $ qf $. ca' reordered |*| qf "1200" |*| sd "sya" |*| end $. p 3  -- **

let contrast = [1,5/4,3/2,15/8,135/64,27/16,45/32,9/8] -- min = 5/4, not 1 or 7/8
d1 $ qf $. ca' contrast |*| qf "400" |*| sd "sya" |*| end $. p 6 -- **


dur 6 -- ** 1/1 lydian + 5/4 dorian scales, just-intoned
 -- tricky interweaving so that the triad is always pretty
let fracs = [1,45/32,15/8,3/2,25/12,5/4]
d1 $ sl 2 $ qf $. ca' fracs |*| qf "200" |*| sd "sya" |*| end $. p 6

-- june 12

dur 1.2
d1 $ sd "sya" |*| qf "440" |*| ga "1.2"
d1 $ qf $. st' [1,9/6,10/6,7/6] |*| qf "400" |*| sd "syb" |*| end "0.9"
d1 $ qf $. st' [1,9/8,10/8,11/8] |*| qf "400" |*| sd "sya" |*| end "0.9"
d1 $ qf $. sl 3 $. cat [st' [1,9/7,10/7,8/7],                                                              st' [1,9/8,10/8,11/8],                                                             st' [1,9/6,10/7,7/6]] |*| qf "200" |*| sd "sya" -- **


-- june 7

let triad = "1 1.2 1.5" :: Pattern Double
let transposes = "1 1.1 1.5 1.2" :: Pattern Double
d1 $ every 2 (rev . fast 1.5) $ sound "bd sn*2"
d2 $ qf triad |*| slow 4 $. qf transposes |*| sound "sy" |*| qf "440"
d3 $ du 0 2 4 (rl (1/8)) $ qf "1 2*2 [3.5 6.5]*2 3" |*| sound "sya" |*| qf "440" |*| qfa "3" |*| qff "1.9" |*| slow 2 $. qaf "0.1 0.01" |*| ga "1.1"
do d1 si; d2 si; d3 si;
d4 $ duty 1 1 2 (fast 1.5) $ sound "[hc hh/3]*8"

dur 1
let i = sound "sy" |*| qf "440"
d1 $ duty 0 1 4 (|*| qf "1.25") $ i
d2 $ duty 1 1 4 (|*| qf "1.25") $ i |*| qf "1.5"
d3 $ duty 2 1 4 (|*| qf "1.25") $ i |*| sl 2 $. qf $. ca' [8/5,7/4]

d1 $ i |*| qf "[1,1.25,1.5,1.625,1.875]" |*| slow 4 $. qf "1 1 1.333 1.5" |*| end "2"
d1 $ i |*| slow 8 $. qf "[1,1.25,1.5,1.875] [1,1.25,1.625] [1,1.2,1.5,1.8]" |*| slow 4 $. qf "1 1 1.333 1.5" |*| end "2"
d2 $ sound "bd [sn ~ ~ sn/4]"

-- with jeff c
dur 1.5
d1 $ sound "[hc hc/5]*8" |*| slow 1.5 $. gain $. ((+ 0.5).(*0.5))<$>tri1
d2 $ every 2 (rr (1/4)) $ stack [sound "bd ~ bd*2 ~" |*| ga "0.85", sound "~ sn ~ sn"]
d4 $ sound "cr/4"  |*| sl 8 $. coarse "4 11"

h
dur 3
d1 $ sound $ st [ "[bd*4,sn*5]", rr (1/5) $ "[ho cr]/2" ]


d1 $ every 2 (fast 2) $ sound "bd hh*2"
d2 $ speed "1 1.25*2 1.5 2" |*| slow 3 $. speed "1 1.2 1.3333" |*| sound "ba" |*| gain "1.2"

-- may 5
dur 1.2 -- **
let i = sd "sya" |*| qf "220"
d4 $ du 0 1 3 rev $ du 0 2 8 (fa 2) $ sd "[bd sn]/2 ho" |*| ga "0.85"
d3 $ qaf "0.2 0.25 0.3333 0.75 0.9" |*| qf $. p (1/4) |*| sl 4 $. qf "7 12 9 13" |*| i |*| qfa "1.75" |*| sl 8 $. qff "0.5 1 2" |*| fa 3 $. qpf "0.025 64" |*| sl 16 $. qpa "0.25 1 16 256"

dur 1.2
d2 $ sl 3 $ qpf $. ca' [1/4,13,3/2,9/7,6/13,4/5,7/6,11/7] |*| sd "sya" |*| qpa "2" |*| qaf $. p (7/5) |*| qfa $. p (11/7) |*| qff "1 2 3 4"

dur 0.8 -- sya<->sy : rad
d1 $ sd "sya*2" |*| qaa "1 0" |*| qaf $. p (11/8)

let tf ch = du 0 2 3 ch . du 0 2 4 rev
d1 $ tf (fa 2) $. qf "1 1.2 1.9" |*| sl 4 $. qf $. ca' [7/8,8/7,1,9/7] |*| sd "sy" |*| qf "[200,1200]" |*| qaf $. p (1/7) |*| qfa $. p (2/3) |*| sl 4 $. qff $. ca' [1/4,1/2,1,0.1,2] |*| qpa "20" |*| qpf "0.1 1 10 100"
d2 $ tf (sa 2) $. sd $. st ["bd sn", rl (1/2) "hh*2"] |*| ga "1"

d1 $ fast 2 $ sd "sy" |*| qaf rand |*| qpa rand |*| qpf rand |*| qfa rand |*| qff rand |*| ga "1.1" |*| end "0.6"

d1 $ sa 2 $ du 0 2 8 (rev . fa 2) $. qf "[1,1.25,1.5] [1.3 1.6 1.9]" |*| du 0 4 16 (rev . fa 2) $. sl 3 $. qf "1 1.3 1.4" |*| i |*| sl 2 $. qaf "1 0.016"
d2 $ du 12 4 16 (|*| si) $ sd "[[bd bd/4] sn]/2 [hh sn/8]"

-- june 1

dur 2
d1 $ ev 2 rev $ sd "sy*8 sy*4" |*| qf "60 [300 [333,10]]" |*| qaf "[5.5,7]" |*| end "0.3" |*| ga "1" |*| qpf "5" |*| qfa "0.1 [2,7] 16" |*| qff "0.25" |*| sl 4 $. qf "1 1.2 0.75 1.333"

d2 $ ev 8 (fa 2) $ ev 4 (rev) $ ev 2 (rl $ 1/4) $ sd "bd sn:1" |*| ga "1.2"
d3 $ rl (1/5) $ sd "hh*2"
d3 $ qff "0.0625*2 0.125 0.25*4 [0.04 0.002]/2" |*| qfa "1" |*| sd "sy" |*| qf "100" |*| qf "3 [7,[4 3]/4] [11 15]/2"
d1 $ ev 3 (sl 2) $. ev 2 rev $. qff "0.01*3 0.1 0.2 0.25*2 3.33 4.25" |*| ev 3 rev $. qfa "0.0625 0.25 1 4 16 64" |*| sd "sy" |*| qf "400" |*| ev 5 rev $. qpf "21 111 0.2 3" |*| qaf "0.15 1 4 22"
d1 $ qf "440 330*2 550*4" |*| sl 4 $. qf $. fmap (flip (/) 8) "5 7 9 11" |*| qpf "0.1" |*| qaf "0.5 [0.222,0.3,0.4] 0.55" |*| sd "sy"
d3 $ qf "0.2 0.75 2 3 5 6.5" |*| qaf "[2,3,7,11]" |*| sd "sy" |*| sl 4 $. qf "55 110 220 330" |*| ga "0.9"
d2 $ sl 2 $ sound "[bd ~ bd/3] [sn:1 sn/4 [~ sn:1]/2]"

d1 $ fast 1 $. qpf "1.3" |*| sd "sy" |*| qf "110" |*| sl 4 $. qf "1 2 3 3.5" |*| end "2" |*| qaf "0.35"

d4 $ sd "syb" |*| ga "1.1"

-- May 31

dur 0.2 -- * was great, is now half-broken
let i = sd "si" |*| qf "[100,150]" |*| slow 4 $. qf "2 2.5 [1 3 5 7 11 13] 3.5"
let q=12 in d1 $ slow q $ qf $. fmap (flip (/) 5) $. run q |*| i
let q=20 in d2 $ slow q $ qf $. fmap (flip (/) 4) $. rev $. run q |*| i
let q=30 in d3 $ slow q $ qf $. fmap (flip (/) 3) $. run q |*| i
let q=36 in d4 $ slow q $ qf $. fmap (flip (/) 7) $. rev $. run q |*| i

let root = qf "400"
let len = end "3"
dur 3
d1 $ root |*| sp "1" |*| sd "si" |*| qf "[1,1.5]" |*| len |*| ga "1.5"
d1 $ root |*| sp "1" |*| sd "si" |*| qf "[1,1.49830707]" |*| len |*| ga "1.5"

let i = qf "300" |*| sd "sia"
dur 2
d1 $ qaf "300*8 700*3 1100" |*| qf "800*4 500 110 230 400" |*| sd "sia" |*| end "3"
d1 $ qf "1 1.25*3 1.5 1.7" |*| slow 3 $. qf "1 1.75 0.75" |*| qaf "1 400 700 3 1111 11 500 350 750" |*| sd "sia" |*| qf "400" |*| end "3"
d2 $ (ssr sa [3,4,16,64,128]) $ ev 2 (fa 2) $ sd "bd hh sn:1 hh"

d1 $ qf "400" |*| qaf "1" |*| sd "sia" |*| qf "2"



--
dur 1
d1 $ qf "[0,7]" |*| sd "si"
d1 $ sp "[1,1.5]" |*| sd "si"

-- May 27

-- SuperDirt!
d1 $ sd "[bd:3 [lt ~]/2] [sn:1 [ht ht*2]/2]"
d2 $ n "1 1.2 [1.3333 [5 7]/2]" |*| n "11 22" |*| n "[16,15]" |*| sd "si" |*| sp "0.5" -- works!
d2 $ n "1 1.2 [1.3333 [5 7]/2]" |*| n "11 22" |*| n "[16,15]" |*| sd "o_si" |*| sp "0.5" 

d1 $ nd "61" |*| sd "o_si"
d1 $ sd "imp:20"
d1 $ sd "gabor:20"

d1 $ n "0 3 7.5" |+| sd "o_si:60" -- 7.5 becomes 7, because n :: Pattern Int -> _
d1 $ sp "4" |*| sd "o_si:60" -- speed is ignored
d1 $ sp "800" |*| sd "si" -- any freq lower than 5513 is inaudible
d1 $ sp "1 1.2 1.5" |*| sp "5513" |*| sd "si" -- any freq lower than 5513 is inaudible

--
let cc = [0,4,7,10]
let cf = (+5) <$> cc
let cg = (+7) <$> cc
d1 $ up $. cat $. fmap stack [cc, cf] |*| sd "ps"


dur 0.3
d1 $ up "[0,4,7,10]" |*| sd "pl" |*| up "12"
d1 $ up $. (+5)<$> "[0,4,7,11]" |*| sd "pl" |*| up "0"

-- 
-- uniform-stacked just chords
dur 2
let chord num den reps = st' [(num/den)^i|i <- [0..reps]]
d1 $ fa 2 $ sp $. cat [chord 5 3 4,chord 12 11 4,chord 9 7 3] |*| up "-12" |*| sd "pl" |*| sp "1 2 1.5" |*| sl 3 $. sp "1 2 1.333"
d1 $ fa 4 $ up "-12" |*| sp $. st' [(13/11)^i|i <- [1..8]] |*| sl 8 $. sp "1 1.5 1.2 [1.1111 1.333] 1.0825" |*| sd "pl"
d2 $ sd $ st ["bd sn", du 0 4 8 (rl (1/8)) $rl (1/4) $ fa 2 $ "hh"]

-- ** just box quartads: ?avoid near-octaves, near-tritones
dur 4 -- orig: 2
dur 2
let et12 ratio = 12 * log ratio / log 2 -- to 12et-read just fractions
let box frac1 frac2 = (*) <$> [1,frac1] <*> [1,frac2]
d2 $ sd $ st ["bd sn", du 0 4 12 (rl (1/8)) $rl (1/4) $ fa 2 $ "hh"]
d1 $ sl 2 $. up "0*5 [3*4 [-2.04 4.98]*3]" |*| sp $. slowcat $. map (fa 4 . st') [box (5/4) (4/3), box (6/5) (2/3), box (8/7) (3/2), box (9/7) (11/8), box (7/8) (13/8), box (5/8) (3/2)] |*| sd "ps" |*| up "-12" |*| ga "0.9"

d1 $ sl 2 $. up "0*5 [0*4 [0 12]*3]" |*| up "-5" |*| sp $. slowcat $. map (fa 4 . st') [box (9/7) (13/7)] |*| sd "ps" |*| up "-12" |*| ga "0.9"
d3 $ sp $. slowcat $. fmap p $. [(11/7)^i|i<-[0..3]] |*| up "-27" |*| sd "f" |*| ga "0.7"

d1 $ sl 2 $. up "0*5 [-7*4 [-1.5 5.52]*3]" |*| sp $. slowcat $. map (fa 4 . st') [box (8/7) (3/2)] |*| sd "ps" |*| up "-12" |*| ga "0.9"
d2 $ sd $ st ["bd sn", rl (1/12) $ fa 4 $ "hh"]

dur 2
d1 $ st [sd "~ sn", fa 5 $ sd "hh", fa 4 $ sd "ht"]
d2 $ sd "sa*5" |*| sp $. stack $. map p $. box (12/21) (11/7) |*| ga "0.7"

d1 $ sp $. st' $. box (4/3) (7/6) |*| sd "ps"
d1 $ sp $. slowcat $. map (fa 4 . st') [box (6/5) (4/3), box (17/14) (3/2), box (6/5) (3/2), box (7/6) (3/2), box (8/7) (13/8)] |*| sd "ps"

-- arrhythmia
dur 4
d1 $ du 2 3 5 (sl 1.333) $ do {f <- cat $ p<$>[fa 1, fa 2, rl $ 1/8, fa 1.5]; f $ fa 4 $ sd "bd*2 sn:2"}
d2 $ rl (1/8) $ sl 2 $ sd "ga"

-- 20

-- ** with stick, high hat (cheat?) for better apparent rhythm
dur 1.7
let fsi = (|*| si)
d1 $ ev 2 (|*| si) $ sd "bd sn"
d2 $ fa 4 $ du 4 13 16  (|*| si) $ sd "hh"
d2 $ rl (1/8) $ unwrap $ (slowcat $ map p [fa 0,fa 1]) <*> (p $ sd "hh")

-- 05 19

let transforms = cat $ map pure [fast 1, fast 2, fast 3]
d3 $ sound $ transforms <$> ("hh" :: Pattern String)

dur 1
let rhyt p = cat [p, fa 3 p]
d1 $ sd $. pp (rhyt ("x"::PS)) "bd sn bl:1 ps" -- **
d2 $ sl 3 $ up $. pp (rhyt ("0"::PS)) "0*2 5.5 7*2 8.4" |*| sp "[1,2,2.5,3]"|*|sd "[ba,ps]"
d3 $ fa (4/7) $ sd "hc ~ hc ~ [~ hc] [hc ~] ~" -- with next (as altv)

let rhyt p = slowcat $ ($) <$> [rl (1/3),id]<*>[p, fa 2 p, fa 4 p]
d1 $ every 3 (fast 2) $ sound "bd sn"
d1 $ sd $. pp (rhyt ("x"::PS)) "bd sn bl:1 ps" -- **
d2 $ sl 4 $ up $. pp (rhyt ("0"::PS)) "0 3 7" |*| sp "[1,2,2.5,3] [1,1.75,2.25,3.333]"|*|sd "ba"
d3 $ fa (2/7) $ sd "hc ~ hc ~ [~ hc] [hc ~] ~"

-- want append, for high hat rhythm in above
  -- looking for a polyrhythm that would codably achieve the same

--prior lang for same
d1 $ sd $. pp ("x x*3"::PS) "bd sn hh"
d2 $ sl 4 $ up $. pp ("0 0*3"::PD) "0 3 7" |*| sd "f"

--
d1 $ sl 2 $ ssr fa [1,4/3,2,3] $ sd "[bd ~ bd] hc*3" |*| ga "0.7"
d2 $ sl 2 $ sd "ho ht" -- with stick

-- 5 18

dur 1
let i = sd "bl:4" |*| sp "0.15"
d1 $ sp $. st' $. ((/) 13) <$> [5,6,7] |*| i
d1 $ sp $. st' $. ((/) 18) <$> [5,10,8] |*| i
d1 $ sp $. st' $. ((/) (27) . fr . (*3)) <$> [11+1%3,8+1%3,6+1%3] |*| i
d1 $ sp $. st' $. (flip (/) (14) . fr . (^2)) <$> [2..5] |*| i

-- **
dur 0.6
let i = sd "pl:4" |*| sp "0.15"
let r1 = sl 4 $ "f*4 f*2 f [~!! [~ f]]"
d1 $ sd r1 |*| sp $. st' [9,8,7] |*| i
d2 $ rl (1/3) $ sl 2 $ sd r1 |*| sp $. st' [3,7,11] |*| i

d1 $ sp $. st' $. ((/) 17) <$> [5,10,7] |*| i |*| sl 8 $. sp "[1 1.4]/2 0.8571" |*| sl 4 $. sp "1 2 3 4"
d1 $ sl 2 $. up "0 0*2 0 [0*2 0*3]/2" |*| i |*| sp $. st' $. ((/) 15) <$> [5,10,7] |*| sl 4 $. sp "1 [1.2 2.2] 1.5 [3.5 3.66]" |*| sp "1.5"

d2 $ sd $. du 3 4 8 (fmap $ (\spl -> case spl of "sn" -> "hh"; x -> x)) "bd [sn!! sn*3]/4"


d1 $ sp $. st' $. (flip (/) 13) <$> [5,6,7]

-- may 16

let i = sd "pl" |*| sp "22"
d1 $ sp $. st' [1/15,1/12,1/10] |*| i
d1 $ sp $. st' [1,12/11,13/11,14/11] |*| i |*| sp "0.1" -- "major"!
d1 $ sp $. st' [1,15/11,3/2] |*| i |*| sp "0.0666"
d1 $ sp $. st' [1,15/11,(5/4)*(15/11)] |*| i |*| sp "0.0666"
d1 $ sp $. st' [1,5/4,3/2] |*| i |*| sp "0.0666"
d1 $ sp $. st' [1,11/8,3/2] |*| i |*| sp "0.0666"

let sl' xs = concat $ map (\(a,b) -> [a,b]) $ zip xs xs
dur 2
let i = sd "pl" |*| up "30"
d1 $ sl 3 $ (fa 2 $ sp "2") |*| sp $. ((/) 1) <$> "7 6 5" |*| i
d2 $ sl 3 $ sp $. ((/) 1) <$> "13 12 11 10 9 8 7 6 5 4 3" |*| i |*| fa 3 $. sp "2 2" -- *** inverse harmonics: 3 (, 6, 12, ...), not 2, sounds fundamental

d2 $ sl 2 $ fa 3 $. sp "[0.6666, 5 3 1]" |*| sp $. ((/) 1) <$> "16 15 14 13 12 [8*2 6*2]/4" |*| i |*| sp "4"

-- ** numerator and denom seqd different, concurrent
  -- it's such weird ear-training math!! e.g:
  -- [18 15 12]^(-1) = 12et 0 3 7 (in order)
d2 $ sl 2 $ fa 5 $. sp $. ((/) 1) <$> "12 9 8 7" |*| sp "8 12 13 7.5" |*| i |*| sp $. p (1/2)
d2 $ fa 5 $ sl 2 $ sp $. ((/) 1) <$> "[12,20] 12" |*| i |*| sp "6 [5 4 3]/3"

dur 1
d2 $ sp $. ((/) 1) <$> "[12,[20 19 18 19]/4] 15" |*| i |*| sp "8"
d2 $ sp $. ((/) 1) <$> "[10,[17 16 15 16]/4] 12" |*| i |*| sp "6"
d2 $ sp $. ((/) 1) <$> "[9,[17 16 15 16]/4] 13" |*| i |*| sp "6"
d1 $ sl 2 $ ssr fa [1,4/3,2,3] $ sd "[bd ~ bd] hc*3" |*| ga "0.7"

d1 $ sp $. (/) 1 <$> "[3,2]" |*| i |*| sl 16 $. sp "2 1.6 1.2" -- perfect fifth
  -- strangely, the low pitch is the high number
d1 $ sp $. (/) 1 <$> "[6,5,4]" |*| i |*| sp "3" -- minor triad
d1 $ sp $. (/) 1 <$> "[15,12,10]" |*| i |*| sp "6" -- major triad

>>> resume review here moving downward

d1 $ sp $. (/) 1 <$> "[28,24,20]" |*| i |*| sp "8"
d1 $ sp $. (/) 1 <$> "[28,21,20,16,14]" |*| i |*| sp "8"
d1 $ sp $. (/) 1 <$> st' [x*2+3|x<-[0..3]] |*| i |*| sp "8"
let uc start gap count = sp $. (/) 1 <$> st' [x*gap+start|x<-[1..count]] |*| sp $. p $. start + count*gap -- ** under-chord
let uc' start gap count = sp $. (/) 1 <$> st' [x*gap+start|x<-[1..count]]

d1 $ uc' 4 2 2 |*| i |*| sp "4"
d1 $ sl 2 $ cat [uc 6 2 4, uc 6 3 3, uc 7 4 4, uc 7 5 5] |*| i |*| sp "0.5"

d1 $ sp $. (/) 1 <$> "[28,21,20]" |*| i |*| sp "16"
d1 $ sp $. (/) 1 <$> "[24,18,17]" |*| i |*| sp "16"
d1 $ sp $. (/) 1 <$> "[20,15,11]" |*| i |*| sp "8" -- =
d1 $ sp $. st' [0.75,1,15/11]  |*| i |*| sp "0.53" -- =

d1 $ sl 3 $ sp $. (/) 1 <$> "[24 21]*3 18*3 14.4*3" |*| i |*| sp "6"
d2 $ sp $. (/) 1 <$> "[9 10]/2 [13 12] [14.4 15]/2" |*| i |*| sp "6"

d1 $ sl 3 $ sp $. (/) 1 <$> "24*6" |*| i |*| sp "6"
d2 $ sl 2 $ sp $. (/) 1 <$> "10 15 16.666 16 13" |*| i |*| sp "6"

d1 $ sp $. (/) 1<$>"[18,15,9,6]" |*| i |*| sl 4 $. sp "4 3.5"

d1 $ i |*| sp "[24,[18 15]/2,12]" |*| sp "0.025"

d2 $ (ssr rl (sl' [1/3,2/3,1]) $ fa 2 $ sp "1! 2 3") |*| sp $. ((/) 1) <$> "9 7 6" |*| i |*| sp "3"

dur 1
let i = sd "pl" |*| sp "2"
d1 $ sp $. st' [1,12/10,15/10] |*| i
d1 $ sp $. st' [1,14/10,16/10] |*| i |*| sl 8 $. sp $. ca' [7/8, 7/9]
d1 $ sp $. cat [st' [1,14/10,16/10], st' [1,21/12,17/12]] |*| i |*| sl 8 $. sp $. ca' [7/8, 7/9]
d1 $ sp $. st' [1,17/12,19/12,21/12] |*| i
d1 $ sp $. st' [1,15/11,18/11] |*| i
d1 $ sp $. st' [1,15/12,18/12] |*| i
d1 $ sp $. st' [1,7/6,9/6] |*| i
d1 $ sp $. st' [1,9/7,12/7] |*| i
d1 $ sp $. st' [1,10/8,10.5/8] |*| i
d1 $ up "[0,10.5]" |*| i

-- training heartbeat (chose average dur, listening to phase)
dur $ 15.75/17
d1 $ sd "hc!! [sn:1 ht]/2"

dur 2.5 -- with stick
d1 $ st [sd "bd sn/2", rl (1/3) $ sd "hh/3", du 4 5 8 (|*|si) $ sd "hc*3"]

-- one line mutating
d1 $ i |*| sp $. st' [13/10,13/7]
d1 $ i |*| sp $. p 13 |*| sp $. st' [1/10,1/7]
d1 $ i |*| sp $. p 13 |*| sp $. st' [3/14,1/7,1/6]
d1 $ i |*| sp $. p 11 |*| sp $. st' [3/14,1/7,1/6]
d1 $ i |*| sl 4 $. sp $. slowcat[p 10,p 13,p 12] |*| sp $. st' [1/8,1/6,1/7] -- **

d1 $ i |*| sp $. st' [1,10/7,13/7]
d1 $ i |*| sp $. st' [13/10,13/7]
d1 $ i |*| sp $. st' [1,3/2,15/8]
d1 $ i |*| sp $. st' [4/7,12/7]

-- comparing JI, 31et and (if it can reach) 12et
dur 2
let i = sd "bl:4" |*| up "-30"
let i = sd "f" |*| up "-30"
d1 $ i

d1 $ i |*| sp $. st' [1,3/2] -- 3/2 ratio = 7.02 in 12et
d1 $ i |*| up "[0,7]" -- the only harmonic where 12et > 31et
d1 $ i |*| hi "[0,18]" -- 18 in 31et = 6.97 in 12et

d1 $ i |*| sp $. st' [1,5/4] -- 3.86
d1 $ i |*| hi "[0,10]" -- 3.87 !
d1 $ i |*| up "[0,4]" -- 4

d1 $ i |*| sp $. st' [1,7/4] -- 9.69
d1 $ i |*| hi "[0,25]" -- 9.68 !
d1 $ i |*| up "[0,10]" -- 10

d1 $ i |*| sp $. st' [1,3/2,21/16] --21/16=4.71
d1 $ i |*| hi "[0,12,18]" -- 12/31=4.65

d1 $ i |*| sp $. st' [1,11/8]
d1 $ i |*| hi "[0,14]"

d1 $ i |*| sp $. st' [1,6/5,3/2]
d1 $ i |*| hi "[0,8,18]"
d1 $ i |*| up "[0,3,7]"

d1 $ i |*| sp $. st' [1,5/4,7/4,7/3] -- dom #9
d1 $ i |*| hi "[0,10,25,38]"
d1 $ i |*| up "[0,4,10,15]"

d1 $ i |*| sp $. st' [1,13/8]
d1 $ i |*| hi "[0,22]"
d1 $ i |*| up "[0,3,7]"


-- just variations on $ 12et [0,3,7] [0,2,6]
let i = sd "bl:4" |*| up "-12"
let i2 = sd "si"
dur 0.35
d1 $ i |*| sp $. st' [8/7,10/7,1]

d1 $ i |*| sp $. st' [1,9/8,45/32]
d1 $ i |*| sp $. st' [1,6/5,3/2]
d1 $ i |*| sp $. st' [1,7/6,35/24]

d1 $ fa 2 i2 |*| sp $. st' [1,4/3,5/3]
d1 $ i |*| sp $. st' [9/8,3/2,15/8]
d1 $ i |*| sp $. st' [1,5/4,3/2]
d1 $ i |*| sp $. st' [11/8,11/7,55/32]
d1 $ i |*| sp $. st' [11/7,55/28,11/8]

d1 $ i |*| sp $. st' [9/7,12/7,15/13] -- beautiful sus, irreducible
d1 $ i |*| sp $. p $. 6/7 |*| sp $. st' [1,3/2,35/26] -- same chord
d1 $ i |*| sp $. st' [9/7,12/7,8/7]
d1 $ i |*| sp $. st' $. (flip (/) 7) <$> [9,12,15]

d1 $ i |*| up "-0" |*| sp $. st' [4/5,9/10,1]

d1 $ i |*| sp $. p (1) |*| sp $. st' $. [21/20,7/5,7/4]



-- approximating harmonics -- div semitones by 6 > by 7
  -- by 6, 13/8 is the first big miss; by 7 (below), 11/4 is
let f freq = 12 * log freq / log 2
mapM_ putStrLn $ map (show.f) [3/2,5/4,7/4,11/8,13/8]
7.019550008653875
3.863137138648349
9.688259064691248
5.513179423647567
8.405276617693106
mapM_ putStrLn $ map (show . flip (/) 7) [1..7]
0.14285714285714285
0.2857142857142857
0.42857142857142855
0.5714285714285714
0.7142857142857143
0.8571428571428571
1.0

-- just parallel figures! but awkward.
dur 1.2
let subset sc indices = map (\i -> sc !! i) indices
let harmony sc iListList  = cat $ map (st' . subset sc) iListList
  -- harmony sc1 [[0],[2,4]]
let n_ad n gap = (*gap) <$> [0..n-1]  -- as in triad. n = nVox
let n_ads maxRoot nVox gap = map (\shift -> (+shift) <$> n_ad nVox gap) [0..maxRoot-1] -- -> [[scale index]]
let sc1 = take 100 $ concat $ repeat [2,9/8,5/4,4/3,3/2,5/3,15/8]
let sc2 = take 100 $ concat $ repeat [1,35/32,5/4,21/16,3/2,25/16,7/4]
let sc2 = take 100 $ concat $ repeat [1,21/16,3/2,7/4]
let sc2 = take 100 $ concat $ repeat [1,35/32,5/4,21/16,3/2,49/32,7/4]
d1 $ up "-5*8" |*| sl 7 $. sp $. harmony sc2 $. n_ads 7 3 2  |*| sd "si" |*| sp "[1]"

let c1 = st'[1,3/2,7/4,5/2,11/4,25/16]
let c2 = st'[1,3/2,7/4,5/2,11/4,3]
let c3 = st'[1,3/2,7/4,5/2,11/4,3]

d1 $ up "0*8" |*| sp $. cat [c1,c2] |*| sd "si"

-- st

d1 $ sd "si*8" |*| sp "[[1 0.875 0.85]/3, [[1.333,1.666] [1.375, 1.625] [1.2 1.4,1.6]]/3]" |*| sd "si"

dur 1
let st' fracs = stack $ map pure fracs
let ca' fracs = cat $ map pure fracs
let ibl = sd "bl:4" |*| up "-36"
let isi = sd "si" |*| up "-7" |*| ga "0.77"
let c1 = sp # st' [1,3/2,5/2,13/4]
let c2 = sp # st' [3/2,7/2,13/5]
let c3 = sp # st' [3/2,11/3,11/5]
d1 $ sp "1*8" |*| sl 2 $. cat [c1,c2,c1,c3] |*| slow 20 $. sp # ca' [1,8/7,7/6,6/5] |*| isi
d2 $ sd "bd [hh sn/5 ~ bd/3]"

-- 2016 05 09

do h; dur 3
let n = 12
solo $ d1 $ sd "ade:3"
d1 $ (sl 2 $ sd $ flip samples (run $ n) $ fa n "ade")
d3 $ sd "ab:2*4"
d2 $ sl 2 $ sd "cp"

d1 $ sd $ flip samples "1 2 3" $ fa 2 $ pp ("hh"::PS) "hc hh ho"

--

let st' fracs = stack $ map pure fracs
let cat' fracs = cat $ map pure fracs
let reps n fracs = concat $ map (\a -> take n $ repeat a) fracs
let i = sd "f" |*| vowel "[a,u]"
let mel = [7/8,1,9/8, 8/7,1,6/7,11/3]
d1 $ hi "-31*4" |*| slow (tr $ length mel) $. sp $. cat' mel  |*| sp $. st' [1, 3/2, 11/4] |*| sd "si"
d1 $ hi "-18*4" |*| slow 7 $. sp $. cat' [7/8,1,1,9/8, 8/7,1,6/7] |*| sp $. st' [1, 3/2, 11/4] |*| sd "si"
-- 5/4, 7/5, 
d2 $ slow 4 $ sp $. cat' $. reps 4 [ 10/9, 9/8] |*| i

d1 $ sp $. st' $. ((*) $ 1/2)<$>[1, 5/4, 7/5, 3/2] |*| i

d1 $ hi "-12" |*| up "[0,3,7]" |*| i
d1 $ hi $. f1 $. flip (-) 18 <$> [6, 14, 24] |*| i
d1 $ hi "-12" |*| sp $. f1 [1, 6/5, 3/2] |*| i

 -- 18,12,28, 

dur 0.8
d1 $ hi $. f1 $. flip (-) 18 <$> [9,19,-4,27] |*| i
d1 $ hi $. f1 $. flip (-) 18 <$> [0,18,5,10] |*| i
d1 $ hi $. f1 [18,8,29,10]  |*| i
d1 $ hi $. f1 $. flip (-) 13 <$> [18,5,26]  |*| i
d1 $ hi $. f1 [0,18,10]  |*| i

let i = sd "f" |*| vowel "o"
let f1 fracs = stack $ map pure fracs
d1 $ sp $. f1 [1,2,12/7]  |*| i
d1 $ sp $. f1 $. (*) (12/7) <$> [1/2,1,7/8] |*| i
d1 $ hi $. f1 [0,31,14]  |*| i

d1 $ sp $. f1 $. (* (6/7)) <$> [1,2,6/5]  |*| i

d1 $ sd "f" |*| vowel "o" |*| slow 10 $. sp "[0.5*10, 1 1.1 1.2 1.3 1.333! 1.3125!  1.25!]"

d1 $ stack [du 0 4 8 (|*| co "7") $ du 0 8 16 (|*| up "39") $ sound "bd:5 ~ bd" |*| slow 4 $. sp "1 1.5 1.25 1.1" |*| ga "1 0.65" |*| vowel "[a a e i o u]/6" |*| d "1" |*| df "0.6" |*| dt $. pure (1/9), slow 2 $ sound "bd"] -- **
d2 $ rr (1/9) $ fa 3 $ sound "hh" |*| ga "0.7"
d3 $ rr (1/3) $ slow 4 $ sd "sn"

-- sim
d1 $ stack [sound "bd:5 ~ bd" |*| slow 4 $. sp "1 1.5 1.25 1.1" |*| ga "1 0.65" |*| vowel "[a a e i o u]/6" |*| d "1" |*| df "0.6" |*| dt $. pure (1/9), slow 2 $ sound "bd"]
d2 $ rr (1/9) $ fa 3 $ sound "hc" |*| ga "0.7"
d3 $ rr (1/3) $ slow 4 $ sd "sn"
|*| co "1"
|*| cr "2" -- broken?

d1 $ sr 10 $ sound "bd:5"

dur 0.3
d1 $ sound "f" |*| slow 5 $. vowel "a e i o u" |*| cr "4.01 3.01"

-- 2016 5 4

-- crush => ringy, artificially long toms possible

-- It would be nice if
  -- |*| was $. For that would need each pattern to be
  -- pattern -> pattern, and for d1 :: (Patern -> Pattern) -> Pattern
  -- but maybe $'s associativity is in the wrong direction

-- polyrhythms
dur 0.13
let (b1,b2) = (7,5)
let (i1,i2,i3)=(sd"bd", sd"sn", sd"hc"|*|ga"0.55"|*|co"11")
d2 $ stack [sl b1 i1, slow b2 i2, i3]

d2 $ slow 4 $ stack [sound "[sn*4,bd*5]", sound "hc*20" |*| ga "0.7"]

-- 31et studies
dur 0.3
let i p = p |*| sound "si" |*| hi "-31"
d1 $ slow 5 $ i $ hi "[0 31 62 93 124]"
d1 $ i $ hi "[-31, 0, 18, 25*2, 31]"
d2 $ i $ hi "31" |*| hi "[14*4 [12! 7!]]/8"

dur 0.9
d1 $ i $ hi "[35*3,10,17*2,20*2,28*3]"                                  |*| hi "-10" |*| co "5" |*| ga "0.7"


d1 $ hi "[0,[7 8 9 10 11]/5,18]" |*| sound "pl"
d1 $ hi "[0,[7*3 8*3 9*3]/9,[13 14 15]/3,18]" |*| sound "pl"

d1 $ hi "[0,8,13,18]" |*| sound "pl"
d1 $ hi "[0,7,14,18]" |*| sound "pl"
d1 $ hi "[14,[20*5 28*6]/8,8,1]" |*| sound "pl"
dur 0.6

d1 $ hi "[0,10,[17 18 19 20 21 22]/4]" |*| sound "pl"
d1 $ stack [hi "[0,18]", slow 4 $ hi $ (+18) <$> run 4] |*| sound "pl"
d1 $ hi "[18,[25*2 26*2 20*4 21*4]/4]" |*| sound "pl"

d2 $ slow 6 $ hi "0 2 4 6 8 10" |*| sound "pl" |*| hi "31"
d2 $ slow 6 $ hi "0 1 2 8 9 10" |*| sound "pl" |*| hi "31"

h
let i = sound "f" |*| hi "-31"
d3 $ slow 2 $ hi "[11 12 13 14 15 16 17]/7" |*| i
d2 $ slow 2 $ hi "[-31, 10*2 18*2]" |*| i |*| ga "0.85"

d2 $ slow 4 $ hi "[0,18] [-6, 12]" |*| hi "-31" |*| i
d3 $ slow 4 $ hi "[0,7]*4" |*| hi "0 2" |*| hi "10" |*| i

d3 $ slow $. 2*9 $ hi $. (+1) <$> run 9 |*| i
d2 $ slow 2 $ hi "[-31, 10*2 18*2]" |*| i |*| ga "0.85"

d1 $ slow 2 $ hi "[-17, 8*2, 14*2, 32*4]" |*| i |*| ga "0.75"
d2 $ sound "bd*4 [hc*2!!! hc*3!!!]/8"


-- (+-) broke!
let t = DP 2 $ sound "bd"
let t' = DP 1 $ sound "~ cp"
let tSum = t +- t'
(arc $ dpPatt tSum) (0,4)

(arc $ dpPatt $ (DP 2 $ sound "bd*2") +- (DP 3 $ sound "cp*2")) (0,6)

-- shift
let p = Pattern $ \(s,e) -> if s <= 1 && e > 1 then [((1,2),(1,2),"bd")] else []

--
let t = DP 1 $ sound "bd"
(arc $ dpPatt $ 3 *- t) (0,4)

--
data DutyCyc a = DC {dur :: Rational, phase :: Rational, wavelen :: Rational}

if 3 > 23 then 23 else if 3 > 4 then 4 else if 3 > 1 then (*10) $ 1 else 0

let t = Pattern $ (\x -> [((0,1),(0,1),"bd")]) :: Pattern String


--

arc (slow 2 $ sound "bd cp cp") (0,1)

d1 $ sound "bd"
d2 $ wqt (+ 0.125) $ sound "sn*2"

d2 $ wqa (max (1%2) . (2*)) $ sound "sn*4"

d1 $ withQueryTime (\(a,b) -> (a, (a + b)/2)  ) $ sound "bd*2 ~"

d1 $ withQueryArc (\(a,b)->(a,b+1)) $ sound "bd*2 ~"

data DutyCyc = DutyCyc {dur :: Rational, phase :: Rational, wavelen :: Rational}

zoom :: Arc -> Pattern a -> Pattern a -- Tidal.Pattern
zoom a@(s,e) p = splitQueries
  $ withResultArc (mapCycle ((/d) . (subtract s)))
  $ withQueryArc (mapCycle ((+s) . (*d))) p
  where d = e-s

let (wqa,wqt) = (withQueryArc, withQueryTime)
let 
let keptStart


-- not looking at just-below while writing just-above

d3 $ sp $. st $. fromRational <$> [1,7/5,7/4] |*| insF

-- is it true, what some piano tuners say, perceived octaves not quite double
  -- testing that with samples: hard, they get digital-thin or short in few octaves
dur 2
do h; let i = sound "cp"
d2 $ striate 12 $ fa 1 $ sound "ho*17" |*| sp "0.35 [3 2] 0.54" |*| ga "2.2" |*| co "55 16 11 2"

d1 $ fa 4 $ i |*| sp $. pure (1/2^7)

do h; dur 2
let shf = slow 7 $ sp $ ap (pure $ 11/12) (pure $ 11/14)
d1 $ duty 0 3 6 (|*| si) $ sound "x*5" |*| sp $. (+2) <$> run 2 |*| insPs |*| shf
d2 $ stack [sound "x*3" |*| sp $. ((*) $ 5/8 ).(+3).(*2) <$> run 3 |*| sound "ba" |*| shf, sound "cp*15" |*| ga "0.5"]

do h; dur 1.6
d1 $ duty 0 1 3 (|*| si) $ sound "x*5" |*| sp $. (+2) <$> run 2 |*| insBa |*| shf
d2 $ duty 0 0 3 (|*| si) $ sound "x*6" |*| sp $. ((*) $ 7/10 ).(+3).(*2) <$> run 3 |*| insPs |*| shf

do h; d1 $ sound "x*4" |*| sp $. (+2) <$> run 2 |*| insBa |*| shf
d2 $ sound "x*3" |*| ap (sp $ (+5) <$> run 3))  |*| insBa |*| shf
d3 $ sound "x*8" |*| sp $. ((+7).(*2)) <$> run 4 |*| insBa |*| sp "0.5" |*| ga "0.8"

-- 29

d1 $ sound "bd sn:1"
d2 $ rl (1/4) $ sound "hh*3 hh"

-- via ben gold, lurk/tidal/"unusual applications"
let beginend bpat durpat = (begin bpat) # (end $ (+) <$> bpat <*> durpat)

d1 $ sound "rave*8" # beginend (slow 4 $ scale 0.1 0.5 saw1) (scale 0.005 0.002 sine1) # loop "6"

-- 2016 04 28

import Data.Math (ln)
convert ratio to 12 tone
let h f = 12 * log f / log 2 -- hzTo12et

-- ** drone
dur 2.2 -- started as comparison; became just decimal intonation
  -- near- (16 Hz) and at-audio-rate striate has pitch effects
let ct1 = "[0,8,18]" -- chord in Thirty-one tone eq
let cw1 = "[0,3,7]" -- in tWelve
let inf = up "7" |*| insPluck |*| sp "0.75" |*| co "7"
h
d4 $ striate 6 $ fast 4 $ up "0" |*| inf |*| up "[-12,7.02]" |*| ga "0.8"
d2 $ duty 0 1 4 (|*|si) $ sl 2 $ rl (1/2) $ up "[0]*8" |*| inf |*| ga "0.7"
d2 $ duty 0 1 4 (|*|si) $ sl 2 $ rl (1/2) $ up "[0, 3.86, 7.02]*8" |*| inf |*| ga "0.7"
-- d2 $ rl (1/2) $ up "[0,4.65, 7]" |*| inf
--d1 $ hi            "[0,12,18]" |*| inf
d3 $ rl (1/4) $ sd "hc"


dur 5 -- 31et
let m1 = "[13 15 13] [~ ~ 0]" :: PD
let f1 p = cat [p,si,si,p]
let f2 p = cat [p,p]
let i = insPs |*| up "0"
d1 $ hi $. f2 m1 |*| insBa
d2 $ slow 2 $ hi $. (f1 . f1) m1 |*| hi $. slow 8 $. (*3) <$> run 8 |*| i
d3 $ duty 0 8 16 (|*| si) $ ssr fast [3,4] $ sound "bd sn"

-- 2016 04 27

dur 0.53
d1 $ gap 14 $ sd "ba"

-- just intonation demo, responding to blaerg's "unusual applications" thread on lurk/tidal
I have enjoyed using Tidal to explore just intonation. Here's a passage that explores four just-intoned chords. (The first, c0, is a just major chord; the others are nothing current music theory has words for.)

cps 2
let v = sound "metal"
let chord = stack . map pure
let c0 = chord [1,5/4,3/2]
let c1 = chord [1,7/4,13/4]
let c2 = chord [9/8,7/5,13/11]
let c3 = chord [9/7,7,3,13/14]
d1 $ (speed $ slowcat [c0,c1,c2,c3]) |*| speed "0.15" |*| v

-- 2016 04 26

dur 6
d1 $ fast 4 $. duty 1 2 4 (rl $ 1/2) $. up "0! ~ 7! ~ -5!" |*| up "7" |*| sound "bd"
d1 $ fast 4 $. duty 1 2 4 (rl $ 1/2) $. up "0! ~ 7! ~ -5!" |*| up "7" |*| slow 4 $. up "0!! 2! 4 5 [7 10]" |*| sound "bass"

dur 6
d1 $ fast 8 $ sound "gabba"
d2 $ fast 8 $ sound "[bd,cp/4] hc"

let len = 7
dur $ 0.4 * len -- todo: don't scale by len, it glitches
let g = f len
d1 $ fast 2 $ sound $ g ("bass" :: PS) 4 0 "hc" 3 2
d1 $ fast 2 $ g (sound "bass" ) 4 0 (sound "hc") 3 2
d2 $ fast 1 $ g (sound "ht" ) 4 0 (sound "noise") 3 2
d2 $ sound $ cat $ replicate len "ho"

-- **** rhythm factory!
let len = 9
dur $ 0.6 * len -- todo: don't scale by len, it glitches
let g = f len
d1 $ duty 1 1 4 (fast 2) $ rl (5/len) $ sound $ g ("bass" :: PS) 2 0 "hc" 3 2
d2 $ fast 2 $ sound $ g ("bd" :: PS) 4 0 "ht" 3 2
d3 $ duty 2 3 4 (|*|si) $ fast len $ sound "hc" |*| coarse "55" |*| gain "0.8"
d4 $ sound "ps" |*| slow 2 $. up "[0,4,7] [3,7,11]"

-- 2015 04 07

hush
let randPitch = fromIntegral . floor . (*12) <$> rand
d1 $ every 4 (|*| up randPitch) $ sound "bass"
dur 2
d2 $ fast 2 $ sd "bd sn"
d1 $ sound "bass*16" |*| fast 2 $. up "0 [0,19]" |*| up (discretise 3 $ fromIntegral . floor . (*12) <$> rand)

d1 $ sound "arpy*16" # speed (struct "x x*2 [x ~ x]" $ scale 1 2 rand)

dur 1.2
hush
d5 $ slow 2 $ rr (1/20) $ up $. pp "0*2 0*2 ~ 0*2 0" "7 13 10 12 8" |*| sound "bass" |*| up "12" -- |*| coarse "29"
d1 $ sound $. pp "x! ~ x ~" "bd sn"
d2 $ duty 1 8 16 (|*| si) $ fast 2 $ sound $. pp "x! ~ x ~" "hc" |*| gain "0.7"
d3 $ slow 2 $ up $. pp "0*2 0*2 ~ 0*2 0" "3 1 7 5 8" |*| sound "bass"
d4 $ duty 4 3 8 (\p -> stack [p, coarse "12" |*| rr (1/5) p]) $ rl (1/2) $ slow 8 $ sound "cp*4"

--

hush
dur 4
d1 $ chop 2 $ chop 2 $ chop 8 $ insF |*| up $. fromIntegral . floor . (*12) <$> rand |*| coarse "4" |*| gain "0.7"
d3 $ chop 2 $ chop 2 $ chop 8 $ insF |*| rl (1/8) $. up $. fromIntegral . floor . (*12) <$> rand |*| coarse "4" |*| gain "0.7"
d4 $ chop 2 $ chop 2 $ chop 8 $ insF |*| rl (1/2) $. up $. fromIntegral . floor . (*12) <$> rand |*| coarse "4" |*| gain "0.7"

d2 $ sound "bd [sn sn*2 sn sn*3]/4"


dur 5 -- **
hush
let fp pa pb = cat  [pa,si,pb,si]
let fp4 pa pb = cat [pa,si,pa,pb]
let fp2 pa pb = cat [pa,rev pb]
let p1 = fp (sound "bd") (sound "sn")
let p2 = fp (sound "hc") (sound "ht")
d2 $ duty 1 1 4 (fast 2 . rl (1/8)) $ rl (1/8) $ sd "hh*4"
d2 $ every 8 (slow 2) $ every 2 (|*| up "-3") $ every 4 (|*| coarse "22") $ every 2 (fp2 $ append p1 p2) $ rev $ fp4 p1 p2

dur 4
let drum1 = sound "bd sn!"
let swing p = cat [p, rr (2/9) p]
let fifths shf n = mod' (n*shf) 12
let squash n = mod' n 12
d1 $ sound "ps*4" |*| (up "[0,4,7] [[0,4,7] [-2,2,[5 9]/2]]/2" |*| slow 12 $. up $. fifths 5 <$>run 12) |*| up "-12"
d1 $ si
d2 $ duty 0 1 4 (fast 4) $ drum1

hush
cps 2
d1 $ chop 4 $ insBass |*| slow 4 $. up $. fromIntegral . floor . (*12) <$> rand
d2 $ duty 0 1 2 (|*| si) $ insF |*| rl (1/2) $. slow 4 $. up $. fromIntegral . floor . (*12) <$> rand
d3 $ duty 0 3 4 (|*| si) $ insF |*| rl (1/4) $. slow 4 $. up $. fromIntegral . floor . (*12) <$> rand
d4 $ duty (-1) 1 8 (rl (1/4) . rev . fast 2) $ slow 2 $ sd "bd sn"
d4 $ slow 2 $ duty (-1) 2 8 (\p -> stack [p, rl (1/4) $ fast 2 $ rev p]) $ slow 2 $ sd "bd sn"
d5 $ duty 4 12 16 (|*| si) $ rl (1/4) $ sd "hc*2"

-- jam training! random bass, perc
  -- extension: cycle the bass trigger freq: 1 2 1 0=silence
  -- extension: cycle the digital voice count: 1 2 1 0=silence
dur 4
let db = degradeBy
hush
d2 $ fast 1 $ chop 4 $ striate 16 $ insF |*| up "-17" |*| slow 8 $. up $. (fromIntegral . floor . (*12)) <$> rand |*| cut "1"
d1 $ fast 4 $ stack [db 0.25 $ sound "bd cp", rl (1/8) $ db 0.5 $ sound "sn*4"]
d1 $ fast 8 $ sound "[hc*4]?" |*| coarse "132"

-- April 6

hush
dur 1.5
d1 $ rl (1/4) $ sound "bd"
d2 $ slowspread rl [1/2,1/3,1/4,1/3,1/2,2/3,3/4] $ sound "sn"
d3 $ sound "~ hh!!" |*| gain "0.8"

dur 1
d1 $ duty 4 8 16 (fast 2) $ sound "bd"
d2 $ duty 8 8 16 (rl $ 1/3) $ rl (1/2) $ sound "sn"
d3 $ duty 4 4 8 (rr $ 1/12) $ rr (1/4) $ fast 2 $ sound "hc"

dur 1.5 -- meter is 3, is tempting to hear as 4
let c p q = cat [p, q, si]
let sh = 1/3
d1 $ duty 4 2 8 sf $ sound $ c "bd" si
d2 $ rl $. sh^2 $ sound $ rev $ c "sn" "short:1"
let c1 = c "hh" "hc"
d3 $ duty 2 2 4 sf $ rl $. sh^2 $ sound $ c c1 c1
d4 $ duty 0 7 8 sf $ sound "short:1*9"|*| gain "0.54"

-- prev attempts to generalize next

hush
dur 1
let sf = (|*| si)
d1 $ slow 4 $ sound "cp bd!!" -- **** meditate
d2 $ duty 3 4 8 sf $ rl $. 1/2 $ sound "sn" 
d3 $ duty 1 2 4 sf $ rl $. 1/4 $ sound "hc*2"
d4 $ silence
d4 $ duty 0 1 2 sf $ rl $. 1/8 $ sound "hh*4" -- can add $ duty 8 8 16 sf

dur 2.3 -- ****
d1 $ duty 7 2 16 sf $ slow 4 $ sound "gabba bd!!"
d2 $ duty 6 2 16 sf $ rl $. 1/2 $ sound "sn" 
d3 $ duty 2 3 8 sf $ rl $. 1/4 $ sound "hc*2"
d4 $ duty 0 1 4 sf $ rl $. 1/8 $ sound "hh*4"
d5 $ duty 0 16 32 sf $ duty 1 7 8 (|*| coarse "21") $ rl $. 1/16 $ sound "short:0*16" |*| fast 1.5 $. gain $. lin 0.5 0.9 <$> tri1

-- 31

hush
dur 2
d1 $ sound "ps:2*4 metal*4" |*| slow 4 $. up "0 3 7 12"
d2 $ rl (1/4) $ fast 2 $ sound "bd sn"

-- perform-edited; showing four young people at pwl, 2016 03 30

-- rhythm training!
let fracs = sort $ nub $ concatMap (\x -> [x,x*2,x*4]) [1%2,5%8,3%4,7%8,1] --ambit
let fracs = sort $ nub $ concatMap (\x -> [x,x*2,x*4]) [1%2,3%4,1] -- less ambit
let g = do { n <- runRVar (uniform 0 $ fromIntegral $ length fracs - 1) DevRandom :: IO Integer; let r = fracs !! fromIntegral n in do {putStrLn $ show r; cps $ fromRational $ r}}

hush
d1 $ sound "bd"
g
cps $ 2/3
cps $ 3/4
cps $ 1
cps $ 4/3
cps $ 3/2
cps $ 2
cps $ 3
cps $ 4

-- a more ambitious grid
1/2 5/8 3/4 7/8
1 5/4 3/2 7/4
2 5/2 3 7/2
4


--2016 03 28

dur 1.2 -- **
let f1 = (|*| coarse "5")
let f2 = (|*| up "-7")
let fsi = (|*| si)
d1 $ sound "bd" |*| slow 4 $. up "-3 5"
d2 $ rl (1/4) $ fast 2 $ sound "sn"
d3 $ rl (1/8) $ fast 4 $ sound $. pp "x" "hh hc*2 x hc*2 x"

d1 $ duty 0 2 4 f2 $ duty 0 4 8 f1 $ sound "bd" -- **
d2 $ rr (1/4) $ duty 14 2 16 fsi $ duty 0 2 4 f2 $ duty 0 4 8 f1 $ sound "sn"
d3 $ rr (1/8) $ duty 6 4 16 fsi $ duty 0 2 4 f2 $ duty 0 4 8 f1 $ fast 2 $ sound "hh"

d2 $ duty 0 4 8 ((rl $ 1/3).(|*| coarse "11")) $ rl (1/4) $ sound "hh hc"
d3 $ rl (1/4) $ duty 0 4 8 ((striate 77).(|*| coarse "5")) $ striate 8 $ sound "bass"

hush
dur 1
let str n li = slow (fromIntegral n) $ sound $ cat $ take n $ (li :: [PS])
d1 $ fast 2 $ str 13 $ "[bleep insect]/2" : cycle ["[ht lt]/2" :: PS, "[mt ~!!]/4",si]
d1 $ when (\n -> mod n 13 > 7) ( (rl $ 1/2).( |*| coarse "4")) $ sound "hc"
d2 $ rl (1/2) $ (str 11 $ "[hh hc]/2" : cycle ["[metal ps]/2" :: PS,si,si]) |*| coarse "24"

d1 $ slow 2 $ sound "[bd sn]/2 hc hc ~" |*| coarse $. (floor . (*10)) <$> rand
d3 $ slow 4 $ up "0 [0 ~]/2 5 7" |*| slow 4 $. up "2 0" |*| slow 8 $. up "5 0" |*| slow 16 $. up "0 3" |*| insBass |*| gain "1.2"

dur 0.33 -- ***
d1 $ fast 2 $ (str 13 $ "[bleep insect]/2" : cycle ["[ht lt]/2" :: PS, "[bleep:5 ~!!]/4",si]) |*| sound "hc" 
d2 $ rl (1/2) $ (str 11 $ "[hh hc]/2" : cycle ["[metal ps]/2" :: PS,si,si]) |*| coarse "11" |*| sound "bd"
d3 $ slow 4 $ stack [sound "bd cp", rr (1/4) $ fast 2 $ sound "hh*2 ~"|*| gain "0.8"] -- 4s, 50 50

-- **** Polyrhythms!
dur 0.75
d1 $ slow (11/5) $ sound $ cat $ take 11 $ "[bleep insect]/2" : cycle ["[ht lt]/2" :: PS, si]
d2 $ sound $ cat $ take 5 $ "[bd sn]/2" : cycle [si,"hh" :: PS]
d2 $ slow (7/5) $ sound $ cat $ take 7 $ "bd" : cycle [si,"hh" :: PS]
d2 $ slow (6/5) $ sound $ cat $ take 3 $ "sn" : cycle ["hc" :: PS, si,si] -- slow (12/5) to (3/10)
d2 $ slow (4/5) $ hi "[0,10,[18 20 21]/3]" |*| sound "ps" |*| gain "0.7"
d1 $ every 2 (fast 2) $ slow (6/5) $ sound "jv sn ~" |*| up $. ((flip (-) 6).(*12)) <$> rand |*| slow 2 $. up "0 [0,19]"

solo $ d1 $ sound $ cat ["bd","sn"]

-- 24

hush -- **
dur 1.5
let less = when (\n -> mod n 8 > 5) (silence |*|) 
d1 $ less $ fast 2 $ striate 32 $ up "-30" |*| sound "hc" -- |*| gain "0.33"
let f p = cat [p::PS,p,si,p,p,si,si,si]
let g p = cat [p::PS,p,si,p]
d3 $ slow 2 $ (sound $ f $ rev $ f $ "hh") |*| coarse "6"
d2 $ stack $ [sound "bd", rr (1/2) $ less $ sound $ "sn"]
d4 $ slow 2 $ (sound $ g $ rev $ g $ "ps") |*| coarse "128"

hush
dur 1
d1 $ when (\n -> mod n 3 > 1) (|*| coarse "22") $ sound "hc*16"  |*| gain "0.7"
d2 $ sound "bd sn"

hush -- ***
dur 2
let duty phase duty wavelen = when (\n -> mod (n - phase) wavelen < duty)
let df phase = duty phase 2 8 (silence |*|)
d1 $ df 0 $ slowspread striate [3,6,4,8,5,10] $ fast 2 $ sound "hc" -- |*| gain "0.33"
d2 $ sound "bd ~ ~ [[~ ht] ~]/2"
let f p = cat [si,p::PS,p,si,p,p,si,si] -- is rotated once right
let g p = cat [p,p::PS,p,si] -- sim
d3 $ df 4 $ slow 2 $ (sound $ f $ rev $ f $ "hh") |*| up "7" |*| coarse "6"
d4 $ df 4 $ slow 2 $ (sound $ g $ rev $ g $ "ps") |*| up "4" |*| coarse "128"

 -- 2016 03 21

hush -- *** would be good next: pitch gets wherever it's going, rhythm slows
cps $ 1/2
let p1 = run 7
let insPsr' = insPsr |*| gain "0.9"
let mains =  [0,2,4,7]
d1 $ up $. lk12 mains <$> p1 |*| insPsr'|*| slow 4 $. up "-12 0"
d2 $ rl (1/2) $. up $. lk12 [6,9,11] <$> p1 |*| insPsr'
d3 $ slow (6/7) $. sound "bd hh*3 sn hh*3"
let less p = cat [si,p]
let tat p = pp "x! ~ x ~ x!! ~ x ~ ~ ~ ~" p
d4 $ slow 4 $ sound $. cat [less $ tat "hc", less $ tat"insect"]
d5 $ slow (32/7) $ up $. lk12 mains <$> "{0 3 ~ 0}%16 ~ {1 ~ 2 3}%16 ~" |*| insBass|*| gain "1.1"

-- 2016 03 18

hush -- **** stick
dur 8 -- nice fractal balance
let f p = cat [si,p,si,p]
let f2 p = cat [p, f p]
d1 $ sound "ps" |*| up "12"
d2 $ fast 4 $ f $ sound "ps" |*| up "24"
d3 $ rl (1/32) $ sound "[cr:5 [cr,feelfx]]/2" -- offset
d4 $ sound $ f "sn*2"
d5 $ (sound $ f $ f $ "insect*3") -- would like to mute this around phase 0 of the longest cycle (where the feelfx)
d6 $ fast 1 (sound $ f2 $ rev $ f "metal") |*| gain "0.8"
-- d7 $ fast 4 $ sound "{mt! ~ mt ~}%3" -- could not perfect
d7 $ fast 4 $ rl (1/8) $ f2 $ sound "bd sn" -- offset (at new scale)

dur 2 -- ** perform-compose-improvised 2016 03 16
let less p = cat [p,si]
let f p = cat [p,si,si,p]
let g p = cat [si,si,p,si]
hush
d3 $ g $ f $ sound "metal"
d1 $ slow 2 $ f $ f $ sound "hc"
d2 $ slow 4 $ sound $ f $ "sn bd"

hush -- **
dur 1 -- nice fractal balance
let f p = cat [si,p,si,p]
d1 $ slow 2 $ sound $. stack ["bd", f "sn"]
d2 $ slow 16 $ sound $. stack [rl (1/4) "[cr:5 cr]/2", f "bd*2", f $ f "metal*3", fast 2 $ f $ f $ rev $ f "ht"]

let chord ps = stack $ map pure ps
d3 $ fast 4 $ up "-19" |*| speed $. chord [5/5,8/5,10/8,12/10] |*| sound "bleep:4" |*| gain "0.6"

-- 2016 03 16

-- 2016 03 15

hush
dur 4 -- ** stick
let sil = silence
let f p = cat [p,sil,p,sil,p]
let g p = cat [p,p,sil,p]
-- altvs
d1 $ sound $ stack [f $ g "hc hc:1", f "bd sn"]
d1 $ sound $ stack [slow 2 $ g $ f "hc hc:1", f "bd sn"]

let s = sound "bass metal*2 ~ ps ~ cp" |*| pan rand |*| up $. (* 12) <$> rand
d2 $ slow 16 $ g $ f $ g s

-- below are copies
dur (3/2) -- ** dur-tuned to the next parag
let f p = cat [p,silence,p]
let g p = cat [rev p,silence,rev p]
d1 $ slow 2 $ rl (1/2) $. sound $. f "bd sn"
d2 $ slow 1 $ sound $. f $. f "hh" |*| gain "0.8"
d3 $ slow 6 $ f $ rl (0/128) $ sound $. g $. g "hc" |*| gain "0.8"

hush
dur 2 -- **** perc
let f p = cat [p,p,silence,p]
let g p = cat [rev p,p,rev p,silence]
d1 $ slow 2 $ rl (1/2) $. sound $. f "sn" |*| cut "1"
d5 $ slow 8 $ f $ rl (3/4) $. sound $. g $. f "bd" |*| cut "1"
d5 $ sound "[bd! ~ bd]" |*| cut "1"
d5 $ silence
d2 $ slow 2 $ sound $. f $. f "hh" |*| gain "0.8"
d3 $ slow 8 $ f $ rl (1/32) $ sound $. pp (g $. g "mt") "lt! mt! ht" |*| gain "0.8"
d4 $ slow 8 $ rl (11/32) $ sound "[feelfx cr:5]/2"

-- 2016 03 13
dur 2 -- ** dark, dancy
let p1 = "x [x x/2] x*2 ~"
hush
d1 $ slow 4 $ every 4 (rl (1/2)) $ sound $ pp p1 "bd bd sn"
d2 $ every 4 (striate 16) $ sound $. pp p1 "~ hh hc" |*| gain "0.9"
d3 $ slow 2 $ up $. (\x -> stack [x, rr (1/32) x]) $. pp "0!! ~ 0! ~ 0" "0 3 7 9 3 7 6" |*| (insBass |*| cut "1")
d4 $ up $. pp "0! ~ [0 0 0*4]/3!! ~ 0" "7 9 3 7 6 0 3" |*| insPsr |*| gain "0.8"
d5 $ slow 8 $ rr (1/64) $ up $. pp "0! ~ 0 0*2 0 ~ 0*4" "7 9 3 7 6 0 3" |*| insPsr |*| up "-12"

hush
dur 0.45 -- ** funny, no pitch
let f23 p = cat [silence,p,p]
let f24 p = cat [silence,p,p,silence]
--let f34 p = cat [p,p,p,silence]
d1 $ slow 3 $ sound $ f23 "bd/2 sn"
d2 $ silence |*| sound $. slow 4 $. f24 "hh*2"
d2 $ sound $ slow 4 $ f24 "hh*2"
d3 $ sound $ slow 16 $ "bleep:5"
d4 $ slow 4 $ sound "lt*16" |*| gain $. (* 0.6) <$> rev saw1

-- 03 12
dur 4 -- ** monster
d1 $ sound "hh*16" |*| slow 2 $. gain $. lin 0.9 0.7 <$> square1
d2 $ fast 2 $ stack [sound "bd sn", sound $. slow 2 $. rr (1/8) "bleep:5/4" |*| gain "0.7"]
d3 $ hi "31 29 20 18 ~ 10 8 -2" |*| insF |*| cut "1"
d4 $ hi "[0(11,16), [20, 25 41](5,8)]" |*| up "-12" |*| insPsr |*| gain $. slow 2 $. lin 1 0.6 <$> square1
d5 $ slow 8 $ hi "0*8 [[12*2 11*2] [~ [10*2 8*2]]]" |*| up "-24" |*| insF |*| cut "2" |*| gain "1.3" |*| gain "1 0 1 [0 1]"

-- 2016 03 10
hush -- ** frenetic happy
let ps = "[1 1*2]/2 ~ 2*2 ~ 1 ~ [1,2]" :: Pattern String -- * mess with this line (and the next to match)
let beats = 7 -- the duration of ps
let pn = fmap (\_ -> 0) ps :: Pattern Double
let pnDub = stack [pn, rr (1/beats) pn]
let ps1 = filterValues (== "1") ps
let ps2 = filterValues (== "2") ps
dur 2.5
d1 $ slow 2 $ sound $. pp ps "hc hc hh hh [bleep:5 ~]/2" |*| gain "0.8"
d2 $ fast 2 $ sound $ pp ps2 "ht mt ht lt lt:2"
d3 $ slow 4 $ sound $ pp ps1 "gabba sn"
d4 $ fast 2 $ slow 2 $. rl (2/beats) $. up $. pp pnDub "0 [3 4] 7 [9 [-2 3]/2]" |*| up pnDub |*| slow 16 $. up "0 [7 5]"|*| insPsr

d5 $ striate 64 $ rl (3/beats) $ slow 4 $ sound "metal*16 metal:2" |*| up $. pp pn "[0,7*2,16*2,26*4]" |*| fast 4 $. up "0 7 16"
d3 $ striate 32 $ slow 16 $. up "0 7 3 -2" |*| slow 4 $. sound "sax" |*| up "[0,7,16*2,26*4]" |*| gain "0.75"

hush
let p1 = ("x ~ x ~ ~"::Pattern String)
let pp = preplace (1,1) -- **** happy
let f pitches = up (preplace (1,1) ("1 1 ~ ~ ~" :: Pattern Double) $ cat $ map return pitches)
let dbl p = stack [p, rl (2/5) p]
cps $ 1 / 1.1
d1 $ (fast 5 $ sound "hc" |*| gain $. lin 0.3 0.6 <$> tri1) |*| (slow  3 $ gain sinewave)
d2 $ stack [sound $ pp p1 "hh cp cp", slow 3 $ sound "[bleep:4 bleep:5]/2"]
d3 $ every 3 dbl $ rl (2/5) $ f $. concatMap (\x->replicate 4 x) [3,8,3,8,14,10] |*| insBass |*| gain "1.2"
d4 $ f [2,3,8,10] |*| insPsr
d5 $ rl (1/5) $ f [10,14,15] |*| insPsr |*| gain "1.2"

d5 $ silence
d4 $ silence
d2 $ silence
d1 $ silence
d3 $ silence

-- 14
hush -- **** variables rock! (long cycle)
let p4 = "x [~ x] x x" :: Pattern String
let p3 = "x [~ x] x" :: Pattern String
let ds2 = "bd sn" :: Pattern String
let ds3 = "bd sn sn" :: Pattern String
let hh = "hh" :: Pattern String
let h2 = "hh hc" :: Pattern String
let h3 = "hh hc hc" :: Pattern String
let f = preplace (1,1)
dur 2.5
d1 $ every 4 (silence |*|) $ (sound $ f p4 ds3)
d3 $ fast 2 $ when (\n -> mod n 16 > 1) (silence |*|) $ sound "insect:9*8"
d2 $ when (\n -> mod n 16 < 8) (slow 2) $. rr (1/2) $. every 4 (silence |*|) $. rl (1/16) $. sound $. f (fast 2 p4) h3

-- 2016 02 12
hush -- **
dur 2
d1 $ every 3 ((3/10) <~) $ sound "bd ~ cp:1 ~ bd ~ bd sn ~ sn"
d3 $ slow 3 $ sound "ho hc"

dur 1.3 -- ** funky
hush
d1 $ (<~) (3/4) $ every 4 ((1/3) <~) $ sound "bd hh!!"
d2 $ slow 16 $ up "0*4 4*4" |*| sound "bass"
d2 $ slow 16 $ (~>) (3/32) $ up "0*4 [-8,4]*4" |*| sound "[bass,bd]"
d2 $ slow 16 $ up "0 [0*2 ~!!] 4 [4*2 ~!!]" |*| sound "[bd,bass]"

d1 $ every 4 ((1/3) <~) $ sound "bd hh!!" -- *
d2 $ slow 8 $ up "12 10 [9 15] 8 4 [5 8] 11 7" |*| sound "bass" -- spooky

dur 1.7 -- ** portal
hush
d1 $ every 3 (slowspread (<~) [5/10,1/10]) $ sound "bd ~ sn ~ sn:2"
d2 $ fast 5 $ sound "hc:6 hh:7/5" |*| gain "0.6 1"
d3 $ slow 6 $ (<~) (1/3) $ (slow 2 $ up "[0*5 ~] -0.5 [3*5 ~] 6.5")    |*| sound "feelfx:2 feelfx"
-- in a graph, could encode the rhythmic corresp in d1 and d3

hush -- **
dur 1
d1 $ sound "[bd:3 bd:3 hh]/3!! [sn!! sn*2]/4"
d1 $ sound "~                  [sn sn:2]/2"
d1 $ sound "[[bd bd hh]/3!! ~] ~          "
d1 $ sound "[[bd bd hh]/3!! ~] [sn sn:2]/2"

hush
dur 0.9 -- ** jagged rhythm, good for (replace-string "[digit],[digit]")
d4 $ slow 16 $ up "[-2,17](5,12) 9(5,12)" |*| sound "bass"
d1 $ slow 8 $ sound $. pp "x(5,12)" "bleep:7 bleep:5 bleep:4 bleep" |*| gain "0.8 0.7"
d2 $ slow 4 $ (<~) (1/8) $ sound $ pp "x(5,12)" "bd sn"
d3 $ slow 2 $ (<~) (1/4) $ sound "hh(5,12)"

hush -- **** trance, drive
dur 2.5 -- dur in [2.5,5]
d1 $ sound "bd"
d2 $ (<~) (1/4) $ sound "sn*2"
d3 $ when (\n->mod n 4==3) (striate 64) $ (<~) (1/8) $ sound "hh*4"
d4 $ every 4 (striate 4) $ (<~) (1/16) $ sound "hc*8" |*| gain "0.7"
d5 $ (<~) (-1/64) $ slow 4 $ sound "can(5,16) ~ [[bleep bleep:4]/2 ~ ~ [print:3 print:7]/2] ~"
d6 $ silence -- up "0 5 7" |*| slow 4 $ up "[0,4,7] [0,3,7]" |*| sound "ps"
d6 $ up "0 e5 7" |*| slow 4 $ up "[0,4,7] [0,3,7]" |*| sound "ps"
d6 $ up "[0 7](5,16)" |*| sound "ps"
d7 $ up "[0,7](11,16)" |*| slow 4 $. up "0 2 3 5 3"  |*| sound "ps"-- ** rad line
d7 $ up "[9,7](11,16)" |*| slow 4 $. up "0 2 3 5 3"  |*| sound "ps"-- ** rad line
  -- is kind of f
d7 $ up "[0,7](11,16)" |*| slow 4 $. hi "0 2 3 5 3"  |*| sound "ps"-- ** rad line

d7 $ up "[3 5 7 9 11](11,16)" |*| sound "ps"
d8 $ up "[7 9 11 1 3 [5 4]]" |*| sound "ps"

hush -- ** giraffe and pope
dur 12
let f p = up "-4.3" |*| p
d1 $ up "[0 12 5 10]*8" |*| f $. insBass -- is F#, Trev wants D
d2 $ fast 4 $ sound "bd sn"
d3 $ slow 4 $. up "7*16 5*16 3*16" |*| up "12" |*| f $. insBass
d4 $ slow 1 $. up "-0 " |*| sound "koy" |*| gain "1.35"

-- 2015 12 08
hush -- ** goofball blippy march
dur 10 -- f, slightly fractal, is applied to both drums and pitch
let t = "bd ~ sn*2" :: Pattern String
let f t = append t $ append t $ rev t
d1 $ sound $ f $ f t
d2 $ fast 2 $. coarse $. f $. pp (run 3) "10 30 77" |*| sound "ht"
d3 $ fast 4 $. coarse $. f $. pp (run 4) "0 0 0 4 4 7" |*| sound "hh" |*| pan tri1

-- 2015 11 26
hush -- ** by Phil Freeman
dur 1
d1 $ stack [ speed rand4 |+| degrade (sound "hh:4"), slow 2 $ sound "[sn sn ~ bd] [cp bd ~ bd] [bd bd] [hh:2 hh:2 hh:2 hh:2]" |+| speed rand4 |+| cut "1" ]
  -- but where he had "x" I have substituted "~"

d1 $ stack [ speed rand4 |+| degrade (sound "hh:4"),   slow 2 $ sound "[sn sn ~ bd] [cp bd ~ bd] [bd bd] [hh:2 hh:2 hh:2 hh:2]" |+| speed rand4 |+| cut "1" ]

-- 2015 11 21

dur 5 -- ** monster, no rhythm
let sc1 = [0,7,10,14,18,22,25]
let sc2 = [0,4,10,13,18,23,25]
let psInstr = sound "ps" |*| hi $. psCorr<$>"0"
let fInstr = sound "f" |*| hi $. fCorr<$>"0" |*| hi "-93"
let f x = hi $ (sc sc1)<$> x
d1 $ f $. run 7 |*| fInstr
d2 $ f $. (+6) <$> append (run 7) (rev $ run 7) |*| fInstr
d3 $ sound "metal" |*| hi "[0 1 2]/3"

hush -- ** dance, round(chorale)
dur 4
let fInstr = sound "f" |*| hi $. fCorr<$>"0" |*| hi "-93"
d3 $ fast 2 $ sound "{[bd ~]/2 bd*2 sn [~!! hc*2]/4}%7"
d4 $ fast 2 $ sound "{hh*2 cp:1*2 ~}%7"
d5 $ hi "{0*4 0*5 [[6 7]/2 10]/2}%7" |*| fInstr |*| cutoff "0.0035" |*| resonance "0.99" |*| gain "1.5" |*| cut "1" |*| up "12"
d1 $ hi "0 ~ 7 0 0 ~ 10" |*| hi "-13" |*| psInstr

-- ** bowed bass!
hush
let fInstr = sound "f" |*| hi $. fCorr<$>"0" |*| hi "-93"
d5 $ striate 8 $ fInstr |*| cutoff "0.001" |*| resonance "0.99"

-- evening 2015 11 13

hush -- ** wandery, high plucked bass
d2 $ slow 2 $ sound "pluck(11,14)" |*| hi "[0, [10 9 8 7]/4, 18]*4 [1,11,[26 29]/2]" |*| hi "0"
d3 $ fast 1.5  $ sound "can(5,7) can(4,7)" |*| speed $. slow 4 $. (\a->a/3+0.6) <$> triwave1 |*| gain $. fast (4/3) $. (\a->a/2+0.6)<$>triwave1
d4 $ fast 1 $ sound "{[[hh hh*2]/2 sn]/2 [~ [~!! sn]]/4 jv*2 ~ jv}%7" |*| gain "1.2" |*| hi "-7.3 [-1 0.7]/2 10.7"
dur 2.5

-- ** dance, happy childish robot. just inton, mixol-centered.
let rhy n = stack [sound "bleep:4! ~ ~" |*|  speed "0.04" |*| cut $. return n, sound "[sn*2 sn]/2 [sn*3 sn*4]/2 ~ ~" |*|  speed "0.1" |*| cut $. return $. n+100 |*| gain "0.9"]
hush
d1 $ (<~) (1/2) $ rhy 1 |*|           speed "8          [7  15 ]/2!!"
d2 $    slow 3 $  rhy 2 |*| speed "[13 12]/2  [10 9.33]/2!!"
d3 $              rhy 3 |*| slow 2 $. speed "[5 3]/2    4"
d4 $ fast 2 $ sound "{hh hh jv*2 ~ jv}%4" |*| gain "1.3" |*| hi "-7.3"
dur 2

-- Just Intonation!
let fracs = nub $ (%) <$> [1..32] <*> [1..32]
map (\a -> (fromRational a :: Double, a)) fracs -- memorize?

hush
d1 $ sound "f f ~ ~" |*| speed " 8  7           !!" |*| speed "0.1"
d2 $ sound "f f ~ ~" |*| speed "[12 [9.33 10]/2]!!" |*| speed "0.05"
d3 $ sound "f f ~ ~" |*| speed "[[5 3.33]/2     2]!!" |*| speed "0.05"|*| cut "1"

hush
d1 $ slow 4 $ sound "[f,ps](11,16)*2" |*| speed "7 [8 9]*3 [13.5,12]" |*| speed "0.1" |*| gain "0.7"

-- 2015 11 13

-- striate turns trem-picked bass into insects, wind-cello
hush -- ** dark, sparse, funky
d3 $ slow 4 $ slowspread striate [1,111,1,7] $ hi "0*8 [3*4 7*4] [18 17 18]*2 [7*2 [7 11]*2]/2" |*| sound "jv" |*| hi "-13"
d2 $ sound $ stack ["bd sn", slowspread (<~) [1/3,1/4,1/6,1/8] "hc:1*2",slow 4 "~ ~ [bd*6 can*6]/2 ~"]
dur 1.5

-- 2015 11 12 -- *** industrial
hush
let ns = [1,7/3] -- parallel bjorklunds + harmonic vector arithmetic
let ns = (%) <$> [10,12] <*> [11,13]
let ns = (%) <$> [10,14] <*> [11,13]
let nof = fmap fromRational
let f = concat . (fmap $ (\n->[-n,n+1/4,n+1/2]) . fromRational)
dur 6
d1 $ silence
d1 $ sound "ps(7,11) bleep:4(8,11)" |*| sps $. f ns |*| sp 0.9
d1 $ sound "ps(9,11) metal:4(6,11)" |*| sps $. nof ns |*| sp 0.6
d2 $ sound $. stack ["bd(3,11)","[gabba bleep:4]/2"]
d3 $ sound $ (7/11) <~ "sn(5,11)"
d4 $ sound $ fast 2 $ "hh(10,11)"

-- ** similar
hush
let sp = speed . return -- really cool
let sps = speed . stack . fmap return -- string-replace ",xx)"
let ns = [1,7/6]
let ns = fmap (\n -> n/2) [1,11/8,9/8]
let f = concat . fmap (\n -> [1/n,1/(n+1)])
dur 6
d1 $ sound "ps(9,11) bleep:4(7,11)" |*| sps ns |*| sp 0.6
d1 $ sound "ps(9,11) bleep:4(7,11)" |*| sps $. f ns |*| sp 0.4
d2 $ sound $. stack ["bd(3,11)","[gabba bleep:4]/2"]
d3 $ sound $ (7.05/11) <~ "sn(5,11)"
d4 $ sound $ fast 2 $ "hh(10,11)"

-- 2015 11 11
dur 4 -- fun: change the denominators, keeping them equal
let p1 = "[0,7] 4 [7,14]" :: Pattern Double
d1 $ sound "can(10,11)"
d2 $ sound "bd(3,11)"
d3 $ sound $ (7/11) <~ "sn(5,11)"
d4 $ sound $ fast 2 $ "hh(10,11)"
d5 $ slow 2 $ sound "gabba bleep:4"

hush
d1 $ sound "can(6,10) can(3,5)"
d2 $ sound "[bd sn]*2"

d1 $ sound "can(3,4) can(3,5) can(6,10)"
d2 $ sound "bd*3"
d3 $ sound "ps*4 ps*5" |*| gain "0.65" |*| append p1 $. rev p1
d4 $ sound "bass*4 bass*5 bass*2" |*| gain "0.65" |*| hi $. (3*)<$>p1 |*| gain "1.2"

-- 2015 11 11
dur 0.7
d1 $ sound "f*2" |*| sps [13,17,22] |*| sp ## 0.6/13

d1 $ sound "f*2" |*| sps [11,14,16.5] |*| sp 0.08
d1 $ sound "f*2" |*| sps [8,11,13] |*| sp 0.08
d1 $ sound "f*2" |*| sps [10,13+1/3,14] |*| sp 0.08
  -- ratios 9 12 13 14 = 12et -5 0 1.38 2.67
d1 $ sound "f*2" |*| sps [9/11,9/8,3/2] |*| sp 0.5

d1 $ sound "f" |*| sps [1,7/4,8/5] |*| sp 0.5
d1 $ sound "f" |*| sps [6,7,10] |*| sp 0.125

let sp = speed . return 
let sps = speed . stack . fmap return -- * idea
d1 $ sound "f" |*| sps [10/7,6/5] |*| sp 0.4
-- r 1 7/6 7/5 = 12et 0 2.67 5.83
-- r 10 12 15 16 ~ 12et 0 3 7 8
-- ratios 10 12 17 ~ 12et 0 3 9
-- r 6 9 10 ~ 12et 0 7 9

-- 2015 10 29

let grid n step least = (+least).(*step)<$>[0..n-1]
let root = (5/11) / 16 -- * play this ratio
let c = stack $ fmap return $ fmap (*root) $ grid 3 3 11
let d = stack $ fmap return $ fmap (*root) $ grid 5 1 10
let e = stack $ fmap return $ fmap (*root) $ grid 3 4 9
d1 $ slow 3 $ striate 4 $ sound "f*16" |*| speed ## cat [c,d,e] |*| speed "0.8"

let grid n step least = (*n).(+least)<$>[0..n-1]
let c = stack $ fmap return $ fmap (*(1/16)) $ grid 3 2 10
let c = stack $ fmap return $ fmap (* 1.5) [2/3,3/5,4/7,6/7,1]
let c = stack $ fmap return $ fmap (* 0.5) [8/6,8/9,5/4]
let c = stack $ fmap return $ fmap (* (1/8)) [3,7/2,9/2,18/2]
let c = stack $ fmap return $ fmap (* 0.5) [8/6,7/9,5/4]
d1 $ striate 8 $ sound "f*3" |*| speed c |*| speed "0.8"

-- ** 31et scales, alien
let p7 = "0! 3 [2 4] ~ [0 3] 3" :: Pattern Int
let dr7 = "can(4,7)"
let p3 = "0 [3 1] [2 0 -1]" :: Pattern Int
let dr3 = "can*3"
let p4 = "0 2 2 [4 2]" :: Pattern Int
let dr4 = "can(3,4)" -- prev are used next
let p = cat [p7,   p4,  p3, "0"]
let dr = cat[dr7, dr4, dr3,"can*2"]
let sc1 = (*4) <$> [0..7] :: [Int]
dur 4
d1 $ sound ## stack [dr,"[bd [~ sn ~ ~]/4]*4"]
d2 $ hi ## sc sc1 <$> p |*| insF |*| cut "1"
d3 $ hi ## sc sc1 . (+2) <$> ((+) <$> p <*> rev p) |*| insF |*| cut "2"

-- Compound meter! pN|drN = pitches|drumline in N meter
let p7 = "0! 3 [2 4] ~ [0 3] 3" :: Pattern Int
let dr7 = "can(4,7)"
let p3 = "0 [3 1] [2 0 -1]" :: Pattern Int
let dr3 = "can*3"
let p4 = "0 2 2 [4 2]" :: Pattern Int
let dr4 = "can(3,4)" -- prev are used next
let p = cat [p7,   p4,  p3, "0"]
let dr = cat[dr7, dr4, dr3,"can*2"]
let sc1 = (*4) <$> [0..7] :: [Int]
dur 7
d1 $ sound dr
d2 $ hi ## sc sc1 <$> p |*| insF |*| cut "1"
d3 $ hi ## sc sc1 . (+2) <$> ((+) <$> p <*> rev p) |*| insF |*| cut "2"

cps 1
d1 $ slow 4 $ sound "[can(3,6) can can(4,5), [bd [hh*3 ~]/2 sn]*2]"

d1 $ sound "[[~ hh*2], ho/3, [~ bd sn]/2, can(3,8) can(2,3)]"

d1 $ fast 1.2 $ speed "[]*2" |*| insF |*| speed ## return (4/7)
d2 $ slow 4 $ speed "[5,6,15*6]" |*| insF |*| speed ## return (1/7)
d3 $ fast 6 $ sound "[hh, hh:1/24]" -- 24=slow4*fast6

hush
dur 2
d1 $ speed "[7,6,9]*2" |*| insF |*| speed ## return (1/7)
d2 $ fast 2 $ speed "~ [15,[10,12]]/2" |*| insF |*| speed ## return (1/7)
d3 $ fast 6 $ sound "[hh, hh:1/24]" -- 24=slow4*fast6

-- 2015 10 28

dur 1
let sp = speed
let sc1 p = sc ([1,4/3,3/2,7/4] :: [Double]) <$> p -- ?broken
let sc2 = [1,4/3,3/2,7/4] :: [Double] -- ?broken
d1 $ sp ## sc sc2 <$> "0 1 2 [3,2]" |*| insPsr

-- let dns p = cat [p, rev p, append p $ rev p, slow 2 $ p]
let dns p = cat [p, rev p, append p $ rev p]
let sc1 = [0,5,10,13,18,20,25]
let sc1 = [0,2,8,13,18,20,29]
-- let sc1 = [0,4,8,14,18,22,25]
-- let sc1 = [0,3,10,18,20,24,27]
let p1 = "0 [1 2] 3*3 [2 1]*3" :: Pattern Int
dur 9
d1 $ striate 2 $ slow 3 $ hi ## dns ## sc sc1 <$> p1 |*| insF |*| cut "1" |*| hi "31"
d2 $ slowspread striate [1,2,4] $ slow 3 $ ((1/6) <~) ## hi ## dns ## sc sc1 . (+2) <$> p1 |*| insPsr |*| cut "2"
d3 $ striate 4 $ slow 6 $ ((2/6) <~) ## hi ## dns ## sc sc1 . (+4) <$> p1 |*| insSine |*| hi "-31"
d4 $ fast 1 $ sound ## dns "bd sn hh*2!"
let ck w = striate 7 $ stut' 3 (5/16) (|*| hi "1") w
d5 $ fast 4 $ sound "jv*15"
d5 $ fast 1 $ ck $ sound "jv*59" -- striate 7, jv 59, dur 9 => in tune
-- d5 $ fast 4 $ ck $ sound "[jv*18, jv*27, jv*21]"

hush
dur 8
let ck w = stut' 3 (3/16) ((|*| hi "1").(|*| coarse "0.5")) $ striate 32 w
d5 $ fast 1 $ ck $ sound "jv*16 hh*31"

hush
cps 0.25
let v2 = "ps metal"
d1 $ striate 33 $ slow 12 $ rn |*| gain "0.4" |*| shape "0.9" |*| pan ## (* 0.5) <$> ((+) <$> triwave1 <*> fast 6 sinewave)
d2 $ fast 1 $ sound "[bd!! [bd! sn]]/4"
d3 $ fast 1.5 $ sound "hh:3*3" |*| gain "0.8"
d4 $ d4 $ stut' 7 (1/5) ## ((|*| gain "0.4").(|+| shape "3").(|*| crush "0.7")) $ slowspread ($) [striate 6, chop 4, chop 16] $ slow 4 $ hi ## psCorr <$> "0 -31 [~ -43]" |*| gain "1 0.8!" |*| sound "ps"
d5 $ slow 4 $ hi ## f1 ## sc [0,8,13,18,28] <$> r1 |*| v2

hush
d1 $ slow 4 $ stut' 9 (3/14) (\x -> x |*| coarse "16" |*| hi "0.5" |*| gain "0.97") $ hi "{14 18, 16 18 20}%8" |*| sound "ps!! [bd hh]"
d1 $ slow 4 $ hi "{14 18, 16 18 20}%8" |*| sound "ps!! [bd hh]"
d2 $ slow 4 $ hi "[[0,25] 0] [18*16 [25 7]*7 ]/4 8*4 7*4" |*| sound "[jv,metal]" |*| slow 8 ## hi "13 [0 [0 8]]" |*| fast 8 ## hi "0 0.7"
d3 $ slow 8 $ hi "[29 33]*5 31 18*3 ~" |*| v1
d4 $ slow 2 $ sound ## stack ["bd*4","can(13,16)"] |+| pan ## slow 4 triwave1

cps 0.5
d1 $ slow 3 $ sound "hh(3,7) bd(3,2) jv(3,8)" |+| hi m1
d2 $ slow 18 $ hi (append m2 $ rev $ (+13)<$>m2) |*| slow 4 ## hi mLar |*| hi "-62" |+| sound "ps"
d3 $ slow 9 $ hi ## cat [m1,m2,append m3 $ rev m3] |*| slow 4 ## hi mLar |*| hi "-13" |+| sound "ps"

-- 26

-- 2015 10 24

d1 $ weave' 3 (sound "bd [sn drum:2*2] bd*2 [sn drum:1]") [density 2, (|+| speed "0.5"), chop 16] -- example of weave', not mine

d1 $ weave' 3 (sound "hh*4") [density 2,(|+| speed $.. run 4)] -- no effect?
d1 $ weave' 5 (sound "[bd*2,hh] hh") [density 4, (|+| hi "18"), chop 20, striate 4] -- what is weave's first arg? duration?
cps 1

d1 $ weave' 1 (sound "ps") [(|+| hi "31 18 8"),(|+| hi "18"),striate 8,(|+| hi "8"),chop 32]
d2 $ weave' 1 (sound "ps") (|+| hi "[31, 18]")

hush
dur 4 -- YES
d1 $ hi "[31,18] [8,25 12] [8,12] [8,18]^3" |+| sound "ps"
d1 $ spread' striate ## slow 4 "1 2 1 8" ### hi "0 14 0 18*2 0 [20,30] [0 8, 18 25] ~" |+| sound ## slow 3 "[drum insect,metal]/2 metal [ps [ps ps:2] ps ps:4]/4"

-- broken, not imeed obvious how to fix
d2 $ slow 2 $ stack [sound "bd [sn!! [sn*3 sn*4 [sn ~ ~ sn] sn*2]/4]/4", spread' chop (slow 4 "1 4 1 16") $ sound $ samples "hh*4" $ slow 4 $ run 15, spread' striate (slow 4 "3 [[[8 1] 8 1] 8 1] 32 1") $ sound $ (1/8) <~ fast 16 "hh hh:2*2 hh:3 hh:6*4" |*| coarse "[0 1]*8" -- fast 2 of this also good

hush
cps $ 1.5 -- learning samples
let p' = "[kurt bd*2] [mouth,insect] [can]*3 sn" -- was slow 2
let p = cat [p','p', rev p', rev p', rev p']
d1 $ slowspread striate [1,4,2] $ chop 3 $ sound (pick <$> slow 2 "[kurt bd*2] [mouth,insect] [can]*3 sn" <*> slow 5 "0 1 2 3")
let p = slow 2 "[kurt bd*2] [mouth,insect] [can]*3 sn"
d2 $ sound $ slow 2 "[kurt bd*2] [mouth,insect] [can]*3 sn"

cps 1 -- ** disco
d1 $ sound $ pick <$> "bd [lt ~]/2 cp [hh*2]" <*> slow 4 $.. run 5 -- after <$> can't provide variable
d2 $ sound "bd sn"

hush -- wonderful trick; not the greatest music yet
dur 1.8
let p1 = "x! ~ [x! ~ x]]"
let p2 = slow 2 $ append p1 $ rev p1
let f = preplace (1,1)
let v1 = "bd sn"
let v2 = "ps metal"
d1 $ sound $ stack [f p1 v1, (<~) (1/2) $ f p2 v2]
let m1 = "[0 8 [18 22]] [[22 9] 27 13]" :: Pattern Double
let m2 = cat [m1, (*2)<$> m1, (+ (-10)) <$> rev m1, append m1 $ (+ (-18)) <$> m1, "25*2"]
d2 $ slow 5 $. hi m2 |+| sound "ps"

hush
let p = (+ (-3)) <$> "0*2 2 4 1*2 3 5 4" :: Pattern Int
let q = slow 4 $ cat [p, rev p, append p p, (\x-> 1.5*x-5) <$> compress (2/7,4/7) p]
let s = [0,4,14,18,21,25,28] 
let s = [0,12,18,25,29,36] -- out of bounds scales work!
d1 $ hi $. sc s <$> stack [q, (+) <$> q <*> "3 [13 1 -7 -11]/3 6 2"] |+| sound "ps" -- in-scale harmony!
d2 $ sound "bd ~ sn bd ~ [sn cp ~ sn*2]/4 [~ hh:3*2]/2"
d3 $ spread' striate $. slow 3 "1 [16 2] [4 1]" $ sound $. samples "noise*14" $. slow 4 $. run 10 |+| slow 4 $. gain "1 [2 1] 0 [2 1]*2" |*| hi $. sc s <$> q

d1 $ sound $ stack [slow 2 "bd [sn*2 sn]/4 [sn lt*2]/2", slow 3 "hh cp:1", samples "hh*2"$ slow 8 $ append (run 4) (run 5)]

hush
dur 1
d3 $ slow 2 $ sound "bd sn sn"
d2 $ slow 3 $ sound "hh cp:1"
d1 $ sound "hh"

hush
let p = "bd sn"
d3 $ slow 7 $ sound $ preplace (1,1) "x ~ x x ~" p
d2 $ slow 5 $ sound $ preplace (1,1) "x ~ x x ~ x ~" p
d1 $ sound "hh"
cps 3

hush
let p = "bd sn metal metal:3"
d3 $ slow 5 $ sound $ preplace (1,1) "x ~ x x ~" p
d2 $ slow 3 $ sound $ preplace (1,1) "x ~ x" "metal cp"
d2 $ slow 3 $ sound $ preplace (1,1) "x ~ x" p
d1 $ silence
d1 $ slow 6 $ sound $. samples "insect*5 industrial*5" $. slow 4 $. (5+) <$> append (run 5) (run 3) |+| gain "0.75"
cps 5 -- x-meters? x-(dur,meter) in phase! 
  -- each has factors for 3/5 or 5/3 or 1/15 or 15, can't tell which

  -- preplace: can make last (Pattern) arg a var, but not the one before that

d2 $ slow 3 $ sound "metal cp ~"

preplace (1,1) "[x ~ x] ~ [x x ~]/2 ~" "ho hc hc:2"

-- 2015 10 23 -- explodes!
let y1 = "0 5 7 12 17 19" :: Pattern Double
let y2 = append y1 y2
cps (1/40)
d1 $ up y2 |+| sound "jv"

-- 2015 10 22

-- broken, tantalizing
dur 4 -- the 1/5 below is the weirdest
let m1 = listToPat [0, 3, 6]
let m2 = listToPat [0, 2, 4, 6]
let n1 = cat [m1, rev m1, m2, rev m2]
let n2 = cat [n1, (1/5) <~ n1] -- this evaluates even if the last n1 is n2, that is, recursively! But then it can't stop playing.
d1 $ hi $. n1 |*| r |+| pan "0"
d2 $ hi $. slow 2 $. n2 |*| r |+| pan "1"
d3 $ fast 4 $. sound "bd sn"

cps 11
d3 $ fast 4 $. sound "jv ps" |+| pan $. slow 16 triwave |+| hi $. slow 100 "0 8 18 31 39 49"
d3 $ fast 4 $. sound "jv ps" |+| pan $. slow 16 triwave |+| speed $. slow 100 "1 1.2 [1, 1.25] 1.4 [1 1.5] 1.6 1.666 [1, 1.75] 1.8"

dur 2
let m1 = listToPat [0,  3, 6, 3]
let m2 = listToPat [12,14,16,14]
let m3 = listToPat [12,14,16,14] -- this time by 1s
d1 $ r |+| hi m1
d2 $ r |+| hi m2

-- 2015 10 21

dur 7 -- *** scales
let rp = append (run 3) $ (*2) <$> run 2 -- run pitch
let rg = "1 0.8 1 0.8 0.8" -- run gain
let globShift = slow 8 $ hi "0 8"
let v = sound "ps"
hush
d3 $ hi rp           |*| slow 2 $. hi "0 8"|+| v |+| gain rg |+| pan "0"
d2 $ hi $. fast 2 rp |*|                       v |+| gain rg |+| pan "1"
d4 $ hi "[-31,-13]*8" |+| v |+| gain "0.75" |+| pan triwave1 -- drone
d1 $ sound $. fast 8 "bd hh*2 [sn!! sn*2]/4 hh*2"
let p1 = "~ 4    ~     [4 3 2 1]"
let p2 = "~ [~ 0] [1 2] [3 4]"
let p3 = cat [p1, p2, p1, rev p2] :: Pattern Int
d5 $ fast 1 $. hi $. sc [0,10,18] <$> p3 |+| sound "jv"

hush
dur 15
let dorian = [0,4,8,14,18,22,27]
let upDown = append rr $ (+1) <$> rev rr where rr = run 12
let v = sound "ps"
d1 $ hi $. sc dorian <$> upDown |+| v
d2 $ hi $. slow 2 $. sc dorian <$> upDown |*| hi "-31"|+| v
d3 $ hi $. fast 1.25 $. sc dorian . (+5) <$> upDown |*| hi "-31"|+| v

d1 $ sound "bd sn"

hush
d1 $ hi $. sc dorian . (+0) <$> upDown |+| sound "ps" |*| hi "-31"
d2 $ hi $. sc dorian . (+2) <$> upDown |+| sound "ps" |*| hi "-31"
-- wish: could apply f :: Int -> (Int, Int) to upDown, use one voice

hush
dur 6 -- ** arpeggios!
let v = sound "ps*9"
let s = [0,10,14,18,21,25]
let hump = (\x -> if x > 6 then 0 else x) <$> run 8
let nump n = fmap (+n) hump
let runMaker num = fmap (+ num)
let rr = cat [nump 1, nump 2, nump 3, nump 4, rev $ nump 2] -- TODO: brevity
d1 $ (hi $ fmap (sc s) rr) |+| v |+| cut "2"
d3 $ slow 2 $ (hi $ (1/2) <~ fmap (sc s) rr) |+| v |+| cut "1" |*| hi "-31"
d2 $ slowspread fast [5,10] $ sound "bd ho sn [sn [hh*2!! hh:4]/2]/4"

hush -- ** just inton
dur 4
let v = sound "ps*15"
d1 $ v |+| hi "[0,10] [25,35]" |*| hi "0 -6" |*| slow 3 $. hi "0 -10 -20"
d2 $ v |+| hi "[8,16,26] [10,14,25] [1,14,24] [0,14,25]"

hush -- **cont
dur 1
let v = sound "ps*8"
d1 $ v |*| hi "[0,10] [25,35]" |*| slow 2 $. hi "0 -6" |*| slow 3 $. up "-20 -10 0"

-- 2015 10 14
hush -- ** worth it
d1 $ sound "sn*16" |*| gain $. ((+0.4) . (*0.6)) <$> rand
d1 $ sound "cr*8"
d1 $ density 4 $ sound "bd sn"
dur $ 0.9 * 4
let worthit = "~ [[0 14]/2 -1]!! 8 0 999 ~" :: Pattern Double
let beep = hi "-62" |+| sound "ps:4" |*| gain "0.9" -- @ d3
d2 $ hi worthit |+| sound "[koy,ps]" |*| hi "12" |+| cut "1"
d3 $ sound "metal*32" |+| (slow 3 $ hi "[10*2 ~!!!!!] ~ 10 [18 [25 [41]]]") |*| beep
d3 $ striate 8 $ slow 4 $ hi "[10*2 ~!!!!!] ~ 10 [18 [25 [41]]]" |*| beep

hush
let p1 = "~ 0*2 4 0 2 -2 ~!!! 0*2! -2 2 0 ~" :: Pattern Double -- ghost busters
d1 $ slow 2 $ up p1 |*| up "[7]" |*| sound "[wobble,metal]" |+| kriole "1"
-- want: transpose metal by a different amount than 24

d1 $ striate 24 $ sound "noise2:6*7 [noise2:6*9 noise2:6*12 noise2:7*7]/3"-- pitch from noise! (noise2:7 is quiet) -- *** timbre
d2 $ sound "bd hh hh ~ sn hh hh [~ bd*2]/2"
d3 $ slow 2 $ sound "jv*8" |+| up "0 [[4 -2.3]/2 5]"
d4 $ slow 2 $ sound "ps*8" |+| up "0 4 8 8.5 7 5 4 2" |+| gain "1.1"

let p1 = "~ 0*2 4 0 2 -2 ~!!! 0*2! -2 2 0 ~" :: Pattern Double
hush
d1 $ slow 2 $ up p1 |*| up "[7]" |*| sound "[wobble,metal]" |+| kriole "1"
d1 $ slow 2 $ up p1 |*| up "12" |+| sound "jv" -- Ghost Busters!
d2 $ sound "bd sn"

d1 $ sound "ps*12" |+| speed "1 2 3" |+| speed "0.7 2.3! 1" |*| (fast 4 $ speed "1 1.2")
dur 1.4

-- * recursive arpeggio!
let p1 = (fast 16 $ up "0 1") |*| hi "[0 18 0 31]*4" |*| hi "0 8 18 31"
d1 $ p1 |+| sound "ps" |+| gain triwave1 |+| gain "0.3" |+| pan "-1 0 1 -1"
d2 $ (<~) (13/32) $ p1 |+| sound "ps" |*| hi "-31" |+| gain triwave1 |+| gain "0.3" |+| pan triwave
d3 $ fast 4 $ (3/4) <~ sound "bd [sn!! [sn ~ ~ cp]]/4"
dur 7

hush
dur 2
d1 $ cyc ($) [density 2, rev, slow 2, striate 3, (|+| speed "0.8")] $ sound "[bd*2 [~ bd]] [sn future]*2 cp jv*4"

d1 $ cyc ($) [(|+| pan triwave),(|+| speed "0.768"),(|+| speed "0.75")] $ sound "[bd*2 [~ bd]] [sn future]*2 cp jv*4"

-- chord changes!
dur 1.2
let psc = (+1.82) -- ps correction, to harmonize jv
d1 $ sound "ps*3" |+| (slow 3 $ cyc hi_ob (psc <$> [0,6]) $ "0 18 25 -6") |+| gain (fast 3 $ triwave)
d2 $ cyc (<~) [1/3,0] $ sound "~ jv*3" |+| (slow 2 $ cyc hi_ob [0,18] "0 10 25")

dur 1.2
hush -- *** lush, dark
let fcorr = (+ 7) -- correction for the "f" tone
d1 $ slow 4 $ sound "jv*4 [jv*2 ~] ~ " |+| cyc hi_ob [-10,-18,-0] "0 8 8" |+| gain "1.1"
d2 $ sound "f*6" |+| gain "0.7" |+| cyc hi_ob (fcorr <$> [0,-6]) "[-6 12] [0,10] [14,25]"
d2 $ sound "f*6" |+| gain "0.7" |+| cyc hi_ob (fcorr <$> [0,-6]) "-7 [8,14] 18 [25,27,29] [30,32] [31,31.07]"
d2 $ sound "bleep:4*8" |+| gain "0.5 0.55" |+| cyc hi_ob (fcorr  <$> [-50,-20]) "-7 [8,14] 18 [25,27,29] [30,32] [31,31.07]"
d3 $ slow 4 $ sound "[bd sn]!! [ht [cp sn:1*3]/2]" |+| gain "1.4" -- same
d4 $ sound $ (0.008) <~ preplace (1,1) "[x ~ x] ~ [x x ~]/2 ~" "ho hc hc:2"
d4 $ sound $ slow 2 $ (0.008) <~ preplace (1,1) "[x [~ x]] x [x x*2]" "ho ho:2 hc hc:2"

hush -- * sparse, cheery, mysterious
let sDia = [ 0, 5, 10, 13, 18, 23, 28] :: [Double]
dur 1
d1 $ slow 2 $ sound "ps*9" |+| (hi_ob 0 $ listToPat $ md sDia 2)
d2 $ slow 4 $ sound "ps*4" |+| (hi_ob 10 $ listToPat sDia)

hush -- ** from tidalcycles twitter, I think
dur 2
dur 6 -- 1,2,3,4, even 6 all great
d1 $ rl (1/16) $ (spread'(striate' 4)((+0.2)<$>slow 8 sine1)) $ jux rev  $ sound (samples "[latibro*6,bd]/2""0 7 15") |+| speed "[1 2 1.5 1.2]/4"

d2 $ slow 4 $ striate' 6 4 $ sound "bd latibro*3 hh koy" |+| hi "[31,25] [0,25]"

dur 1.5 -- ** chaos
let f x = slow 8 $ spread' striate "2 12 144" $ spread' chop "2 [4 8 16] 32" $ spread slow [1/4, 2, 4] $ x
let g1 = gain (slow (1/8) $ (*2) <$> triwave)
d1 $ f $ sound "ho ho:2 ho:3 hc" |+| g1
d2 $ f $ sound "koy" |+| gain "1.5"

hush
dur 2 -- ** glitch, fun beat. dur in [1.5,2]
let beat p = slowspread chop [2,3,8,6] $ spread fast [1/3, 1, 3] $ p
let level = gain (slow (1/8) $ (*0.9) <$> triwave)
d1 $ rl (1/2) $ f $ sound "ho" |*| pan "0"
d2 $ f $ sound "gabba" |+| level |+| pan "1" |+| cut "1"
d3 $ fast 2 $ chop 8 $ sound "bd ho sn:2 ho"
d4 $ fast 2 $ stack [sound "bd sn", rl (1/4) $. sound "hh*2" |*| slow 3 $. coarse "4 16 64" ]

hush
dur 2.5 -- ** spooky, esp. slow. dur in [0.625,2.5]
let ic strings = intercalate (" " :: String) strings
cat :: [Pattern a] -> Pattern a
cat ps = density (fromIntegral $ length ps) $ slowcat ps
dat :: [Pattern a] -> Pattern a
dat ps = density (fromIntegral $ length ps) $ slowcat ps
d1 $ slow 2 $ sound "bd [sn ~ ~ bd] [~ bd bd ~] sn" |+| (density 2 $ shape triwave)
d2 $ slow 2 $ sound "hc*4 [~ hc!!] hc*4 [~ hc cr ~]" |+| (density 6 $ gain $ (+0.2) <$> triwave)
d3 $ slow 4 $ sound "bleep:1*8" |+| hi_ob (-31) "0 0 31 13 10 10 4 2" |+| gain "1.4"
d4 $ slow 2 $ (1/16) <~ sound "metal:3*16" |+| hi_ob (-31) "0 0 31 13 10 10 4 2" |+| gain (density 6 triwave) |+| gain "0.7"
d5 $ slow 2 $ (0/16) <~ sound "metal:3*16" |+| hi_ob (-13) "62 93 49 21 29 31 18" |+| gain (density 6 triwave)

-- ** sim, house
dur $ 5 -- dur in [1.25,4*1.25]
d1 $ sound "bd [sn ~ ~ bd] [~ bd bd ~] sn" |+| (density 2 $ shape triwave)
d2 $ sound "hc*4 [~ hc!!] hc*4 [~ hc cr ~]" |+| (density 6 $ gain triwave)
d3 $ sound "jv*8" |+| hi "[-13,36]" |*| hi "0 0 31 13 8 8 4 2" |+| gain "1.4" |+| cutoff "0.9" |+| resonance "1"
d4 $ (1/16) <~ sound "bottle:2*16" |+| hi_ob (-31) "0 0 31 13 8 8 4 2" |+| gain (density 6 triwave)
d5 $ (0/16) <~ sound "metal:3*16" |+| hi_ob (-31) "62 93 49 21 29 31 18" |+| gain (density 6 triwave)

dur 2.5
hush -- ** sim, dance
d1 $ sound "bd [sn ~ ~ bd] [~ bd bd ~] sn" |+| (density 2 $ shape triwave)
d2 $ sound "hc*4 [~ hc:1!!] ho:1*4 [~ hc cr ~]" |+| (density 2.5 $ pan triwave1)
d3 $ sound "jv*8" |+| hi_ob (3) "0 0 31 13 8 8 4 2" |+| gain "1.4" |+| cutoff "1 0 1 0" |+| resonance "0"
d6 $ ((1/16) <~ sound "ps*8") |+| hi_ob (18-31) "0 0 31 13 8 8 4 2" |+| gain "1.3" |+| cutoff "0.4" |+| resonance "0" |+| pan (density 3 triwave)
d4 $ (1/16) <~ sound "bottle:2*16" |+| hi_ob (-31) "0 0 31 13 8 8 4 2" |+| gain (density 6 $ (\x -> x * 0.8 + 0.2) <$> triwave1)
d5 $ (0/16) <~ sound "metal:3*16" |+| hi_ob (13-31) "62 93 49 21 29 31 18" |+| gain (density 6 triwave)

cps 1
d1 $ slow 5 $ spread chop [2,5,12] $ sound $ samples "hit*8" $ run 10

hush
dur 2.5
d1 $ jux (rev) $ sound "[~ pluck]*7" |+| hi_ob (62-6) "0 10 25 11"
d2 $ slow 3 $ (1/3) <~ sound "pluck*7" |+| hi_ob (-6) "0 7 13 20" |+| gain "1.3"

-- ** devo
dur 1.25 -- [1.25,2.5]
let p1 = " 0  0  10 10 18 18 25 25"
let p2 = " 31 25 25 18 13 13 5  5 "
d1 $ sound "ps*8" |+| hi_ob 0     p1 |+| pan "0"
d2 $ slow 2 $ sound "jv*8 jv" |+| hi_ob (16) p2 |+| pan "1" |+| gain "1.4"
d3 $ (0/16) <~ sound "hc*6 ~" |+| gain "0.8"
d4 $ slow 8 $ sound "gabba sn:2 bd sn:2 bd sn:2 bd sn:2*3 metal sn:2 bd sn:2 bd sn:2 bd sn:2*4" |+| gain "1.4"

-- * dancy
dur 1.25
let p1 = " 0  0   8  8 18 18 29 29"
let p2 = " 29 21 18 17 11 8  8  5"
d1 $ slow 2 $ sound "ps*8" |+| hi_ob (-13)  p1 |+| pan "0"
d2 $ silence
d2 $ slow 2 $ sound "jv*8" |+| hi_ob 18 p2 |+| pan "1" |+| gain "1.4"
d4 $ silence
d4 $ slow 8 $ sound "bd sn:2 bd sn:2 bd sn:2 bd sn:2*3 bd sn:2 bd sn:2 bd sn:2 bd sn:2*4" |+| gain "1.4"
d5 $ slow 2 $ sound "metal*8" |+| hi_ob 0 p2 |+| pan "1" |+| gain "1.4"
d3 $ (0/16) <~ sound "hc*8" |+| gain "0.8"

hush
dur 5 -- **
d1 $ sound  "if:1 sn sn   cp sn ht sn   if sn sn   cp sn sn sn   cp sn ht sn                   if:2 sn sn   cp sn ht sn   cp sn sn   if sn ht sn   if sn ht ~"

d1 $ sound "if:1 sn bd cp sn ht sn if sn sn cp sn ht sn cp sn sn sn                           if   bd bd cp sn ht sn if sn sn if mt ht    bd sn cp ~"
-- = 3* 4 3* 4 4 , 3* 4 3* 3* 4

hush -- **
dur 3
d1 $ slow 8 $ sound "ps*8" |+| hi_ob (-21) "0 8 18" |+| gain "1.3"
d2 $ slow 4 $ sound "ps*8" |+| (1/4) <~ hi_ob (18) "0 8 18" |+| gain "1.3"
d3 $ slow 2 $ sound "ps*16" |+| (1/2) <~ hi_ob (-21) "4 25 41"
d4 $ sound "ps*20"          |+| (2/4) <~ hi_ob (13-21) "18 23 41"
d5 $ slow 0.5 $ (sound $ "hh!! hh*2") |+| pan (slow 3 $ sinewave1) |+| gain "1.2"
